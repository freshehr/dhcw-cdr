{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview This set of documentation will introduce you to some of the principles behind openEHR and how to start working with the APIs and data formats that the various openEHR CDRs (Clinical Data Repositories) support. Postman We strongly recommend that you orientate yourselves using the free Postman tool, as this will let you easily play with the various API calls without writing any code. Once you understand the principles it will be much easier to write code for your own environment, and better still, Postman can often generate code examples in a variety of languages. To make life easier, we have prepared a Postman collection which is essentially a pre-cooked set of openEHR API calls, for which when used with Postman environment files, can be used to point very quickly at an endpoint and get playing. Click the 'Run Postman Button' to import the Postman 'Apperta C4H openEHR REST APIs' collection and the associated Postman environment.. Which API to use? For more information on the various APIs see Overview of the different CDR APIs . To get started we suggest you focus on the Better Ehrscape API. Although this is proprietary to Better and will soon be supplanted by the openEHR REST API, it uses some simplified data formats that can make life much easier. These formats are being adopted by the wider CDR community as part of the openEHR CDR API, so this advice will change, once this is better established. In other respects the Better API is conceptually very similar and you will not find it hard to adjust to the openEHR REST API, indeed one possibility is to use the standard API for most calls. Key content Getting started with Postman and the openEHR REST collection Introduction to openEHR Overview of the different CDR APIs Working with the Better Ehrscape API Working with the openEHR REST API Overview of the Jamaica MoHW Passport project","title":"Overview"},{"location":"#overview","text":"This set of documentation will introduce you to some of the principles behind openEHR and how to start working with the APIs and data formats that the various openEHR CDRs (Clinical Data Repositories) support.","title":"Overview"},{"location":"ehrscape/ECDR1-authentication/","text":"Getting started - Authentication Let's get started by hooking up to an openEHR CDR via the Better Ehrscape API. This API is supported by Better (along with the openEHR REST API) and Ripple Ethercis. We have included examples for the Better CDR used by the Apperta Code4Health platform. Authentication All of the openEHR CDR API calls require some sort of authentication in the header. In production this is likely to be something like JSON Web Tokens (JWT) but for demo purposes both ehrBase and betterCDR support Basic Auth based on a Username and Password. Basic Authentication If you have a Postman environment file related to your CDR, you should be able to find the Username and Password, and possibly the Basic Auth token, pre-calculated. If it is not pre-calculated, it is easy to do so with code like this in javascript. const authString = btoa ( ` ${ username } : ${ password } ` ) const authToken = `Basic: ${ authString } ` You then need to send that token in the Authorization header of your REST call e.g. curl --location --request GET 'https://cdr.code4health.org/rest/v1/template' \\ --header 'Accept: application/json' \\ --header 'Authorization: ' Connecting to the CDR To test our basic connection to the CDR, we will perform a very simple List templates call to list the openEHR templates currently registered with the CDR -> Working with openEHR Templates","title":"Getting started - Authentication"},{"location":"ehrscape/ECDR1-authentication/#getting-started-authentication","text":"Let's get started by hooking up to an openEHR CDR via the Better Ehrscape API. This API is supported by Better (along with the openEHR REST API) and Ripple Ethercis. We have included examples for the Better CDR used by the Apperta Code4Health platform.","title":"Getting started - Authentication"},{"location":"ehrscape/ECDR2-openehr-templates/","text":"Working with openEHR Templates openEHR templates are aggregations of logical archetype models that along with the basic Reference model, act as the validation schema for any patient data submitted to the CDR. You cannot submit any information to a CDR without first registering the template which will be used to validate it. This section will test our connection the CDR by running a List templates call, then upload a new template to the CDR via an Upload a template call. A. List available templates This call simply returns a list of the templates currently registered with the CDR, each with a unique templateId . cURL curl --location --request GET '/template' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : '/template' , headers : { 'Accept' : 'application/json' , 'Authorization' : '' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"/template\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization' : ' ' } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response If your CDR is already provisioned with some templates, you will get a 200 code and some output like this... { \"templates\" : [ { \"templateId\" : \"DHCI - Suspected Covid-19 assessment.v0\" , \"createdOn\" : \"2020-03-03T18:26:47.943Z\" }, { \"templateId\" : \"Vital Signs Encounter (Composition)\" , \"createdOn\" : \"2019-10-29T18:01:30.819Z\" }, { \"templateId\" : \"WHO - Suspected Covid-19 assessment.v0\" , \"createdOn\" : \"2020-02-28T18:46:29.960Z\" } ] } otherwise you should get a 204 code and an empty array. If you get some other error, this is likely to be that you have not set the baseEhrscapeURL correctly, or that the Authorization token is incorrect. B. Upload an operational template (XML) You should be able to find an example 'operational' template in the \\technical\\templates folder. This is an XML file which contains the 'constraints' information required by the CDR to correctly validate anty information that is committed. The template example with templateId : 'DHI - Urology_PROMs-v0' represents a simple data-entry dataset to allow patients with Prostate cancer to record how they are feeling, and then share this with their care team. Don't worry for now about the format of the file itself. It follows the Archetype Object Model (1.4), but is always generated automatically by tools such as the openEHR Archetype Designer. cURL curl --location --request POST '/template/' \\ --header 'Content-Type: application/xml' \\ --header 'Authorization: ' \\ --data-raw '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <template xmlns=\"http://schemas.openehr.org/v1\"> <!-- Snipped for brevity --> </template> ' NodeJS/Axios ```js var axios = require('axios'); var data = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n \\n \\n TRIMMED for Brevity...... \\n'; var config = { method: 'post', url: '/template/', headers: { 'Accept': 'application/json', 'Content-Type': 'application/xml', 'Authorization': '' }, data : data }; Python/requests import requests url = \"/template/\" payload = \"<?xml version= \\\" 1.0 \\\" encoding= \\\" UTF-8 \\\" standalone= \\\" yes \\\" ?> \\n <template xmlns= \\\" http://schemas.openehr.org/v1 \\\" > \\n <language> \\n <terminology_id> \\n <value>ISO_639-1</value> \\n </terminology_id> \\n <code_string>en</code_string> \\n </language> \\n <description> \\n -- Trimmed for brevity --- </template>\" headers = { 'Content-Type' : 'application/xml' , 'Authorization' : '' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response Better CDR will give a 201 response code and return the templateID . { \"action\" : \"CREATE\" , \"templateId\" : \"NES-ACP_COVID.v0.0\" } Overwriting an existing template The BetterCDR allows templates to be over-written by simply re-sending the POST call and returns a 201 code. Better 'Web templates' As well as being used to validate patient records when they are commited to the CDR, templates are used as the basis for many other types of technical artefact, such as automatic forms builders, class library generation, and for client-side validation in UI. Although formally aligned with the in-memory AOM, the operational template can be hard to parse and understand, particularly if you are just trying to understand the various schema constraints. For this purpose, you may find it helpful to generate a 'Web template' - this is a much simpler JSON format, itself based on the operational template, and which can be exported from the openEHR Archetype Designer via the Export menu or retrieved via the Get Web Template (JSON) call. cURL bash curl --location --request GET '/template/' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : '/template/' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : '' , } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"/template/\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization' : '' , } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Now that we have a valid template uploaded, we can Commit a Composition of patient data to the CDR.","title":"Working with openEHR Templates"},{"location":"ehrscape/ECDR2-openehr-templates/#working-with-openehr-templates","text":"openEHR templates are aggregations of logical archetype models that along with the basic Reference model, act as the validation schema for any patient data submitted to the CDR. You cannot submit any information to a CDR without first registering the template which will be used to validate it. This section will test our connection the CDR by running a List templates call, then upload a new template to the CDR via an Upload a template call.","title":"Working with openEHR Templates"},{"location":"ehrscape/ECDR3-committing-a-composition/","text":"Committing openEHR data All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference Model schema. If the data is valid, it will be stored in the CDR and is allocated a unique compositionID , which is returned by the POST /composition call on a successful call. This section will submit an example Composition to the CDR by running a POST /composition - Commit composition call. A number of data serialisation options can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON format. Better Ehrscape: `POST /composition - Commit Composition STRUCTURED' Parameters ehrId : This is is the internal CDR identifier for a specific patient. When a patient is registered with the CDR,an EHR object is created with a unique ehr_id identifier, and is associated with an external subjectId and subjectNamespace e.g an NHS Number, CHI number, or a local hospital number. We will find out how to work out the correct ehrId for a patient in a future section. Generally when you first open a patient record session, you will retrieve their ehrId via their subjectID and subjectNamespace . We will explain how to do that in the next section. For testing purposes, you should use a known ehrId . If you have a Postman environment file, an example will be in there, otherwise you can find out how to identify valid ehrIds here templateId : This is the identifier of the openEHR template, against which you need to validate the composition, in this case DHI - Urology_PROMs-v0 format : This defines the format of JSON or XML that you are sending. Use STRUCTURED for this example. Request Postman cURL curl --location \\ --request POST 'https://rest.ehrscape.com/rest/v1/v1/composition?ehrId=3e674739-950c-4b8a-976b-5aef21c618c5&templateId=DHI%20-%20Urology_PROMs-v0&format=STRUCTURED' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' \\ --data-raw '{ { \"prostate_cancer_proms_report\": { \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"territory\": [ { \"|code\": \"EN\", \"|terminology\": \"ISO_3166-1\" } ], \"context\": [ { \"xds_metadata\": [ { \"document_type\": [ \"Patient recorded outcome measures\" ] } ], \"start_time\": [ \"2020-07-05T13:32:56.186Z\" ], \"setting\": [ { \"|code\": \"238\", \"|value\": \"other care\", \"|terminology\": \"openehr\" } ] } ], \"what_matters_to_me\": [ { \"what_matters_to_me\": [ \"Parents\", \"Mood\", \"Isolation\", \"Eating\", \"Family\", \"Safety\" ] } ], \"howru_score\": [ { \"pain_or_discomfort\": [ { \"|code\": \"at0041\", \"|value\": \"slight\", \"|ordinal\": 1 } ], \"feeling_low_or_worried\": [ { \"|code\": \"at0042\", \"|value\": \"quite a lot\", \"|ordinal\": 2 } ], \"limited_in_what_i_can_do\": [ { \"|code\": \"at0041\", \"|value\": \"slight\", \"|ordinal\": 1 } ], \"dependent_on_others\": [ { \"|code\": \"at0043\", \"|value\": \"extreme\", \"|ordinal\": 3 } ], \"summary_score\": [ 4 ], \"time\": [ \"2020-07-21T15:41:54.175Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"eortc_qlq-c30\": [ { \"trouble_doing_strenuous_activities\": [ { \"|code\": \"at0007\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"trouble_taking_a_long_walk\": [ { \"|code\": \"at0040\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"trouble_taking_a_short_walk_outside_of_the_house\": [ { \"|code\": \"at0044\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"need_to_stay_in_bed_or_a_chair_during_the_day\": [ { \"|code\": \"at0049\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"need_help_with_eating_dressing_washing_yourself_or_using_the_toilet\": [ { \"|code\": \"at0051\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_limited_in_doing_either_work_or_other_daily_activities\": [ { \"|code\": \"at0056\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_were_limited_in_pursuing_hobbies_or_other_leisure_time_activities\": [ { \"|code\": \"at0060\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_short_of_breath\": [ { \"|code\": \"at0064\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_pain\": [ { \"|code\": \"at0067\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_need_to_rest\": [ { \"|code\": \"at0072\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_trouble_sleeping\": [ { \"|code\": \"at0076\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_felt_weak\": [ { \"|code\": \"at0078\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_lacked_appetite\": [ { \"|code\": \"at0084\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_felt_nauseated\": [ { \"|code\": \"at0086\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_had_vomited\": [ { \"|code\": \"at0090\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_have_been_constipated\": [ { \"|code\": \"at0097\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_had_diarrhea\": [ { \"|code\": \"at0099\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_tired\": [ { \"|code\": \"at0102\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_pain_interfere_with_daily_activities\": [ { \"|code\": \"at0109\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_had_difficulty_in_concentrating\": [ { \"|code\": \"at0110\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_felt_tense\": [ { \"|code\": \"at0115\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_worried\": [ { \"|code\": \"at0121\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_felt_irritable\": [ { \"|code\": \"at0123\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_felt_depressed\": [ { \"|code\": \"at0128\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_difficulty_remembering_things\": [ { \"|code\": \"at0133\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_physical_condition_or_medical_treatment_interfered_with_family_life\": [ { \"|code\": \"at0135\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_physical_condition_or_medical_treatment_interfered_with_social_activities\": [ { \"|code\": \"at0138\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_physical_condition_or_medical_treatment_caused_financial_difficulties\": [ { \"|code\": \"at0143\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"rate_overall_health_during_the_past_week\": [ { \"|code\": \"at0147\", \"|value\": \"2\", \"|ordinal\": 2 } ], \"rate_overall_quality_of_life_during_the_past_week\": [ { \"|code\": \"at0157\", \"|value\": \"5\", \"|ordinal\": 5 } ], \"total_score\": [ 61 ], \"time\": [ \"2020-07-15T16:47:06.320Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"i-pss_prostate_score\": [ { \"a1._incomplete_emptying\": [ { \"|code\": \"at0015\", \"|value\": \"Less Than 1 Time In 5\", \"|ordinal\": 1 } ], \"a2._frequency\": [ { \"|code\": \"at0016\", \"|value\": \"Less Than Half The Time\", \"|ordinal\": 2 } ], \"a3._intermittency\": [ { \"|code\": \"at0017\", \"|value\": \"About Half The Time\", \"|ordinal\": 3 } ], \"a4._urgency\": [ { \"|code\": \"at0017\", \"|value\": \"About Half The Time\", \"|ordinal\": 3 } ], \"a5._weak_stream\": [ { \"|code\": \"at0016\", \"|value\": \"Less Than Half The Time\", \"|ordinal\": 2 } ], \"a6._straining\": [ { \"|code\": \"at0018\", \"|value\": \"More Than Half The Time\", \"|ordinal\": 4 } ], \"a7._nocturia\": [ { \"|code\": \"at0060\", \"|value\": \"3 times\", \"|ordinal\": 3 } ], \"total_i-pss_score\": [ 18 ], \"i-pss_score_grade\": [ { \"|code\": \"at0087\", \"|value\": \"8-19 Moderate\", \"|terminology\": \"local\" } ], \"time\": [ \"2020-07-05T13:32:56.186Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"category\": [ { \"|code\": \"433\", \"|value\": \"event\", \"|terminology\": \"openehr\" } ], \"composer\": [ { \"|name\": \"John Smith\" } ] } }' NodeJS/Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"prostate_cancer_proms_report\" : // trimmed for brevity}\"); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/v1/composition?ehrId=3e674739-950c-4b8a-976b-5aef21c618c5&templateId=DHI - Urology_PROMs-v0&format=STRUCTURED' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests `` ` python import requests url = \"https://rest.ehrscape.com/rest/v1/v1/composition?ehrId=3e674739-950c-4b8a-976b-5aef21c618c5&templateId=DHI - Urology_PROMs-v0&format=STRUCTURED\" payload = \"{ \\n \\\" prostate_cancer_proms_report \\\" : { \\n \\\" composer \\\" : [ \\n { \\n \\\" |name \\\" : \\\" John Smith \\\"\\n } \\n ] \\n } \\n TRIMMED for BREVITY }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) ``` Response { \"meta\" : { \"href\" : \"https://rest.ehrscape.com/rest/v1/v1/composition/59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" }, \"action\" : \"CREATE\" , \"compositionUid\" : \"59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" } A successful commit will give a 200 response code. If the JSON is incorrectly formatted or there is a data validation error, you will get an error message. Interpreting validation error messages can be quite challenging for those new to openEHR, so we will cover this in a separate section later. The Composition Id and versioning The compositionId (sometimes uid or compositionUid ) is the unique identifier allocated to (and held within) every composition stored within the CDR. You will see that it ends in ...::1 . The 1 is the version of this composition instance. If you need to update the instance (perhaps because of an error), you need to do so via a PUT / composition call and if successful the composition version number will clock up to ::2 . In essence every commit is versioned and retained for medico-legal reasons. Initial version 2cf04d6c-31e8-4599-a14b-9a0add4de5d9::fivium.ehrscape.com::1 Revised version 2cf04d6c-31e8-4599-a14b-9a0add4de5d9::fivium.ehrscape.com::2 If you need to retrieve a composition, it is normally ok to simply use the root part 2cf04d6c-31e8-4599-a14b-9a0add4de5d9 which will return the latest revision in the current repository. Similarly, when a composition is deleted, this is a logical delete and the composition can always be retrieved, though is not normally accessible via querying. We will go through the process of updating a composition , via a PUT /composition call later. For now let's just retrieve the composition we just committed, via the GET /composition call.","title":"Committing openEHR data"},{"location":"ehrscape/ECDR3-committing-a-composition/#committing-openehr-data","text":"All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference Model schema. If the data is valid, it will be stored in the CDR and is allocated a unique compositionID , which is returned by the POST /composition call on a successful call. This section will submit an example Composition to the CDR by running a POST /composition - Commit composition call. A number of data serialisation options can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON format.","title":"Committing openEHR data"},{"location":"ehrscape/ECDR4-retrieving-a-composition/","text":"Retrieving an openEHR Composition All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better STRUCTURED JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish. Ehrscape GET /composition example Parameters compositionId : This is is the composition UID for the composition you wish to retrieve. Don't worry about how we find that out for now. Just use the UID for the composition you just committed in the last section. We will find out how to find compositionIds in a subsequent section. format : This defines the format of JSON or XML that you are requesting. Use STRUCTURED for this example. A. Retrieve an openEHR Composition ( STRUCTURED JSON ) Postman cURL curl --location --request GET 'https://rest.ehrscape.com/rest/v1/composition/?format=STRUCTURED' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://rest.ehrscape.com/rest/v1/composition/?format=STRUCTURED' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : '' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://rest.ehrscape.com/rest/v1/composition/?format=STRUCTURED\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization' : '' } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response If the composition is found a 200 code will be returned along with the composition object , which you will note now includes the uid, but should otherwise be identical to that which you previously submitted. { \"meta\" : { \"href\" : \"https://rest.ehrscape.com/rest/v1/v1/composition/e921fde4-3800-44c7-b39a-e2c8769a9c1d::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" }, \"compositionUid\" : \"e921fde4-3800-44c7-b39a-e2c8769a9c1d::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" , \"format\" : \"STRUCTURED\" , \"templateId\" : \"DHI - Urology_PROMs-v0\" , \"composition\" : { \"prostate_cancer_proms_report\" : { \"_uid\" : [ \"e921fde4-3800-44c7-b39a-e2c8769a9c1d::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" ] // ..... Snipped for brevity \"composer\" : [ { \"|name\" : \"John Smith\" } ] } }, \"deleted\" : false , \"lastVersion\" : true , \"ehrId\" : \"3e674739-950c-4b8a-976b-5aef21c618c5\" , \"lifecycleState\" : \"COMPLETE\" } Other data formats The Better Ehrscape API offers several other serialisation formats. You can have a look at these by simply changing the format parameter on the GET / composition call, and the call Header Accept to switch between JSON and XML. 'FLAT JSON' This uses the same path-shortening mechanism as structured JSON but flattens all of the tree structure to a set of name-value pairs. Some developers prefer this to the STRUCTURED format. format=FLAT Accept : `application/json' 'RAW JSON' This is very similar to, but not identical to the openEHR Canonical JSON format, which essentially supersedes it. It very closely adheres to the openEHR Reference model specification but is pretty voluminous. format=RAW Accept : `application/json' 'RAW XML' This is 'canonical' openEHR XML which is also accepted by the openEHR REST API. It is the lingu-franca for all openEHR CDRs, even those which do not support the REST CDR API, will normally accept and expose data in this XML format. format=RAW Accept : `application/xml'","title":"Retrieving an openEHR Composition"},{"location":"ehrscape/ECDR4-retrieving-a-composition/#retrieving-an-openehr-composition","text":"All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better STRUCTURED JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish.","title":"Retrieving an openEHR Composition"},{"location":"ehrscape/ECDR5-retrieving-an-ehrId/","text":"Retrieving the patient's ehrId When a patient is registered with a CDR, by supplying their ' subjectId (normally a real-word identifier like an NHS number, CHI number or hospital MRI), a top-level EHR object is created in the datastore along with a unique identifier for that patient. Most of the CDR API calls require an ehrId to identify the correct patient ,so normally the first activity required if interacting with a patient record is to retrieve their ehrId . Hint The only datapoint you really need to retrieve is ehrId . You want to consider caching this for the session, so that it can be used for a number of subsequent calls. Better Ehrscape: GET /ehr - Get ehrStatus from SubjectId Parameters subjectId : This is the external identifier by which the patient is known within the CDR. It is normally a real-word identifier like an NHS number, CHI number or Hospital 'MRI' number, and will have been supplied to the CDR when the patients' EHR object was created in the datastore. Example value : 9999999000 subjectNamespace : This is just a unique string used to identify the numbering scheme used for the subjectId . It will commonly be some sort of URI such as uk.nhs.nhs_number and will have been agreed at national level. Example value : uk.nhs.nhs_number Postman cURL curl --location \\ --request GET 'https://rest.ehrscape.com/rest/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' NodeJs - Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : ' https://rest.ehrscape.com/rest/v1/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://rest.ehrscape.com/rest/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response Better CDR will give a 200 response code and this structure. { \"meta\" : { \"href\" : \"https://cdr.code4health.org/rest/v1/ehr/3e674739-950c-4b8a-976b-5aef21c618c5\" }, \"ehrStatus\" : { \"subjectId\" : \"9999999000\" , \"subjectNamespace\" : \"uk.nhs.nhs_number\" , \"queryable\" : true , \"modifiable\" : true , \"otherDetails\" : { \"@class\" : \"ITEM_TREE\" , \"items\" : [ { \"@class\" : \"CLUSTER\" , \"archetype_details\" : { \"@class\" : \"ARCHETYPED\" , \"archetype_id\" : { \"@class\" : \"ARCHETYPE_ID\" , \"value\" : \"openEHR-EHR-CLUSTER.person_anonymised_parent.v1\" }, \"rm_version\" : \"1.0.1\" }, \"archetype_node_id\" : \"openEHR-EHR-CLUSTER.person_anonymised_parent.v1\" , \"items\" : [ { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Administrative Gender\" }, \"archetype_node_id\" : \"at0001\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Male\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0009\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Birth Sex\" }, \"archetype_node_id\" : \"at0002\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Male\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0009\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Vital Status\" }, \"archetype_node_id\" : \"at0003\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Alive\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0004\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Birth Year\" }, \"archetype_node_id\" : \"at0014\" , \"value\" : { \"@class\" : \"DV_DATE\" , \"value\" : \"1944\" } } ] } ] } }, \"ehrId\" : \"3e674739-950c-4b8a-976b-5aef21c618c5\" }","title":"Retrieving the patient's ehrId"},{"location":"ehrscape/ECDR5-retrieving-an-ehrId/#retrieving-the-patients-ehrid","text":"When a patient is registered with a CDR, by supplying their ' subjectId (normally a real-word identifier like an NHS number, CHI number or hospital MRI), a top-level EHR object is created in the datastore along with a unique identifier for that patient. Most of the CDR API calls require an ehrId to identify the correct patient ,so normally the first activity required if interacting with a patient record is to retrieve their ehrId . Hint The only datapoint you really need to retrieve is ehrId . You want to consider caching this for the session, so that it can be used for a number of subsequent calls.","title":"Retrieving the patient's ehrId"},{"location":"ehrscape/ECDR6-updating-a-composition/","text":"Updating an openEHR Composition All new data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. Most compositions will only need to be updated if an error or omission needs to be corrected. All openEHR data is strictly audited and version controlled, so an Update operation requires a PUT /composition call . You will nearly always with to first retrieve the original version of the composition via a GET /composition call, update the JSON or XML object and then perform the PUT Better Ehrscape PUT /composition - Update composition Parameters compositionId : This is is the composition UID for the previous version of the composition i.e the version that you are about to overwrite. Don't worry about how we find this, just use the uid for the composition you just committed in the last section. format : This defines the format of JSON or XML that you are requesting. Use STRUCTURED for this example. templateId : This is the identifier of the openEHR template, against which you need to validate the composition, in this case, DHI - Urology_PROMs-v0 . Request Postman cURL curl --location --request PUT 'https://rest.ehrscape.com/rest/v1/rest/v1/composition/b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1?format=STRUCTURED&templateId=DHI%20-%20Urology_PROMs-v0' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' \\ --data-raw '{ \"prostate_cancer_proms_report\": { \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"territory\": [ { \"|code\": \"EN\", \"|terminology\": \"ISO_3166-1\" } ], \"context\": [ { \"xds_metadata\": [ { \"document_type\": [ \"Patient recorded outcome measures\" ] } ], \"start_time\": [ \"2020-07-05T13:32:56.186Z\" ], \"setting\": [ { \"|code\": \"238\", \"|value\": \"other care\", \"|terminology\": \"openehr\" } ] } ], \"what_matters_to_me\": [ { \"what_matters_to_me\": [ \"Parents\", \"Mood\", \"Isolation\", \"Eating\", \"Family\", \"Safety\" ] } ], \"howru_score\": [ { \"pain_or_discomfort\": [ { \"|code\": \"at0041\", \"|value\": \"slight\", \"|ordinal\": 1 } ], \"feeling_low_or_worried\": [ { \"|code\": \"at0042\", \"|value\": \"quite a lot\", \"|ordinal\": 2 } ], \"limited_in_what_i_can_do\": [ { \"|code\": \"at0041\", \"|value\": \"slight\", \"|ordinal\": 1 } ], \"dependent_on_others\": [ { \"|code\": \"at0043\", \"|value\": \"extreme\", \"|ordinal\": 3 } ], \"summary_score\": [ 4 ], \"time\": [ \"2020-07-21T15:41:54.175Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"eortc_qlq-c30\": [ { \"trouble_doing_strenuous_activities\": [ { \"|code\": \"at0007\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"trouble_taking_a_long_walk\": [ { \"|code\": \"at0040\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"trouble_taking_a_short_walk_outside_of_the_house\": [ { \"|code\": \"at0044\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"need_to_stay_in_bed_or_a_chair_during_the_day\": [ { \"|code\": \"at0049\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"need_help_with_eating_dressing_washing_yourself_or_using_the_toilet\": [ { \"|code\": \"at0051\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_limited_in_doing_either_work_or_other_daily_activities\": [ { \"|code\": \"at0056\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_were_limited_in_pursuing_hobbies_or_other_leisure_time_activities\": [ { \"|code\": \"at0060\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_short_of_breath\": [ { \"|code\": \"at0064\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_pain\": [ { \"|code\": \"at0067\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_need_to_rest\": [ { \"|code\": \"at0072\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_trouble_sleeping\": [ { \"|code\": \"at0076\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_felt_weak\": [ { \"|code\": \"at0078\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_lacked_appetite\": [ { \"|code\": \"at0084\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_felt_nauseated\": [ { \"|code\": \"at0086\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_had_vomited\": [ { \"|code\": \"at0090\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_have_been_constipated\": [ { \"|code\": \"at0097\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_had_diarrhea\": [ { \"|code\": \"at0099\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_tired\": [ { \"|code\": \"at0102\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_pain_interfere_with_daily_activities\": [ { \"|code\": \"at0109\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_had_difficulty_in_concentrating\": [ { \"|code\": \"at0110\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_felt_tense\": [ { \"|code\": \"at0115\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_were_worried\": [ { \"|code\": \"at0121\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_felt_irritable\": [ { \"|code\": \"at0123\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_felt_depressed\": [ { \"|code\": \"at0128\", \"|value\": \"Quite a bit\", \"|ordinal\": 3 } ], \"during_the_past_week_had_difficulty_remembering_things\": [ { \"|code\": \"at0133\", \"|value\": \"Very much\", \"|ordinal\": 4 } ], \"during_the_past_week_physical_condition_or_medical_treatment_interfered_with_family_life\": [ { \"|code\": \"at0135\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"during_the_past_week_physical_condition_or_medical_treatment_interfered_with_social_activities\": [ { \"|code\": \"at0138\", \"|value\": \"Not at all\", \"|ordinal\": 1 } ], \"during_the_past_week_physical_condition_or_medical_treatment_caused_financial_difficulties\": [ { \"|code\": \"at0143\", \"|value\": \"A little\", \"|ordinal\": 2 } ], \"rate_overall_health_during_the_past_week\": [ { \"|code\": \"at0147\", \"|value\": \"2\", \"|ordinal\": 2 } ], \"rate_overall_quality_of_life_during_the_past_week\": [ { \"|code\": \"at0157\", \"|value\": \"5\", \"|ordinal\": 5 } ], \"total_score\": [ 61 ], \"time\": [ \"2020-07-15T16:47:06.320Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"i-pss_prostate_score\": [ { \"a1._incomplete_emptying\": [ { \"|code\": \"at0015\", \"|value\": \"Less Than 1 Time In 5\", \"|ordinal\": 1 } ], \"a2._frequency\": [ { \"|code\": \"at0016\", \"|value\": \"Less Than Half The Time\", \"|ordinal\": 2 } ], \"a3._intermittency\": [ { \"|code\": \"at0017\", \"|value\": \"About Half The Time\", \"|ordinal\": 3 } ], \"a4._urgency\": [ { \"|code\": \"at0017\", \"|value\": \"About Half The Time\", \"|ordinal\": 3 } ], \"a5._weak_stream\": [ { \"|code\": \"at0016\", \"|value\": \"Less Than Half The Time\", \"|ordinal\": 2 } ], \"a6._straining\": [ { \"|code\": \"at0018\", \"|value\": \"More Than Half The Time\", \"|ordinal\": 4 } ], \"a7._nocturia\": [ { \"|code\": \"at0060\", \"|value\": \"3 times\", \"|ordinal\": 3 } ], \"total_i-pss_score\": [ 18 ], \"i-pss_score_grade\": [ { \"|code\": \"at0087\", \"|value\": \"8-19 Moderate\", \"|terminology\": \"local\" } ], \"time\": [ \"2020-07-05T13:32:56.186Z\" ], \"language\": [ { \"|code\": \"en\", \"|terminology\": \"ISO_639-1\" } ], \"encoding\": [ { \"|code\": \"UTF-8\", \"|terminology\": \"IANA_character-sets\" } ] } ], \"category\": [ { \"|code\": \"433\", \"|value\": \"event\", \"|terminology\": \"openehr\" } ], \"composer\": [ { \"|name\": \"John Smith\" } ] } }' NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'put' , url : 'https://rest.ehrscape.com/rest/v1/rest/v1/composition/b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1?format=STRUCTURED&templateId=DHI%20-%20Urology_PROMs-v0' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Authorization: ' , } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests url = \"https://rest.ehrscape.com/rest/v1/rest/v1/composition/b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1?format=STRUCTURED&templateId=DHI%20-%20Urology_PROMs-v0\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization: ' , } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response { \"meta\" : { \"href\" : \"https://rest.ehrscape.com/rest/v1/rest/v1/composition/b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::2\" }, \"action\" : \"UPDATE\" , \"compositionUid\" : \"b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::2\" } If the update is successful a 200 code will be returned.","title":"Updating an openEHR Composition"},{"location":"ehrscape/ECDR6-updating-a-composition/#updating-an-openehr-composition","text":"All new data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. Most compositions will only need to be updated if an error or omission needs to be corrected. All openEHR data is strictly audited and version controlled, so an Update operation requires a PUT /composition call . You will nearly always with to first retrieve the original version of the composition via a GET /composition call, update the JSON or XML object and then perform the PUT","title":"Updating an openEHR Composition"},{"location":"intro/INT1-overview-openehr/","text":"Introduction openEHR is a non-profit collaborative which promotes an open standards-based person-centric health and care records ecosystem, sometimes referred to as the 'open Platform' approach. It envisages a world where patient/person health and care information is managed coherently in person-centric information stores, independent of the applications that read, write and query the at information. This is quite different from the current norm in healthcare, where thousands of individual applications hold siloed parts of the person's record, in siloed, normally proprietary, logical and physical data formats. Decades of effort have gone into trying to make this 'best-of-breed' approach interoperate, and whilst some positive progress is being made with HL7 FHIR, the limits of 'traditional interoperability are increasingly evident, as the complexity scales-up. The openEHR community believes that traditional interoperability between siloed systems, whilst a necessary part of the story, will not, by itself, deliver the kind of seamless and coherent integration between apps that otherwise has only been possible by acquiring a single, large-scale vendor system, with all of the disadvantages of technical and commercial lock-in that follow. This website also gives a helpful overview of the 'open platform approach' which openEHR is designed to support.openehr-modellinfg The openEHR Clinical Data Repository (CDR) openEHR offers an alternative 'third-way' where apps are increasingly built to work with person-centric, standards-based 'Clinical Data Repository' (CDR) datastores instead of siloed, proprietary datastores. As well as helping promote much tighter integration, this should substantially reduce the barriers to new market entrants by allowing complex services to be provided on top of theCDR e.g integrations with national services such as national medication management. openEHR does not itself create and publish CDR solutions or related applications, rather it provides a specification for the logical information model that underpins this key part of the technology stack. Critically the specification is completely agnostic with respect to the physical database or programming language, used by the CDR. From the perspective of the third-party app developer, they interact almost entirely with the CDR via a relatively small API, standardised data formats and a query language which is based on the logical models, not on the physical database/ schema employed. This allows competing internal CDR designs and technology choices to emerge without disturbing the application's interactions. openEHR systems can be built on any programming language, OS platform and with any persistence solution - examples of SQL Server, Oracle, PostgreSQL, mongoDB and MumpsDB solutions exist. It is the responsibility of the back-end developer to map their chosen persistence solution to the openEHR logical information model and querying system. Splitting the logical information model ... 'two-level modelling' One of the critical innovations in openEHR is the separation of the logical model into two parts. 1. The Reference Model (RM) The RM is a typical technical logical model, published as a set of specifications and UML diagrams. It covers basic engineering requirements for a person-centric health and care record e.g datatypes, generic structures, data commit behaviours, versioning rules. However, the RM, unlike most attempts to build healthcare logical models, has virtually no healthcare domain content - there are no Allergies, Medication or Diagnosis models. The definition and governance of those health and care concepts are left to the Domain modelling layer, however any domain models must be fully compliant with the RM, which is designed so that new and updated models can be incorporated without any re-engineering of the CDR. This is a very critical part of the openEHR ecosystem, and sometimes hard to grasp both conceptually and practically, but it allows CDRs to be be able to handle any new healthcare concepts supplied by the domain modellers without requiring any database re-factoring. It also crucially changes the relationship between the CDR vendor and their customer, since the customer can control/update the data and data definitions within the CDR without any recourse to the vendor. In essence this is not dissimilar to the kind of abstraction provided by Django or Ruby Active Objects, but is designed to work with the health domain, is much more extensible, and is designed to work in a completely language and technology-neutral manner. 2. Domain Modelling (Archetypes and templates) in openEHR, domain concepts like Allergy, Medication order, Procedure, Device are all defined and governed quite separately from the RM, primarily as shareable components known as Archetypes. In practice apps developers will normally work with aggregations of archetypes known as Templates, which represent a specific use-case e.g an application dialog to store a typical nursing 'vital signs' record , including checking the patient's blood pressure, pulse , temperature etc. In order for a CDR to understand these information models, know how to persist and retrieve the information, the requisite templates and archetypes need simply to be registered with the CDR (normally via the CDR API). A thriving community based around exists to develop, publish and share internationally valid archetypes (which cover 70% of most projects) but there is no compulsion to use those archetypes. In that sense, openEHR as a modelling ecosystem more closely resembles the way that the open-source, distributed development community operates. At national, regional and implementer level there is much tighter governance, defining exactly which archetypes should be used. Confused!! These ideas can seem like a stretch to technologists used to tight coupling of app-level information to underyling database products, and to modellers unfamiliar with the 2-level approach. Possibly the best analogy is to the way that HTML/javascript is handled within browsers. Essentially browser manufacturers implement the Domain Object Model (DOM) standard, which at very generic levels defines how to handle HTML, CSS and javascript but says nothing about specific content or theming. That is left to the web designer. In the openEHR world, the RM is equivalent to the HTML DOM. openEHR archetypes can be thought of as being like CSS frameworks or React components, which 'graft' on to the DOM/RM at run-time, but are fully accessible to the programmer via the DOM/RM. If web developers use shared React components or CSS frameworks like Bootstrap or Material, they will achieve some standardisation of behaviour'. Similarly if openEHR developers use the international blood pressure archetype their systems will be interoperable for blood pressure, even if the underlying CDRs have a different vendor or technology. What does an openEHR-based system look like? Logically the overall structure of an openEHR-based system is \u2026 Physical CDR Virtual CDR (optional) EHR FOLDER COMPOSITION SECTION ENTRY CLUSTER ELEMENT name value Every single piece of information recorded in an openEHR system follows this generic pattern .... Physical CDR {Code4Health CDR} Virtual CDR { My CDR Domain } EHR { John Smith } FOLDER { Cardiology pathway } COMPOSITION { Outpatient review letter } SECTION { Investigations } ENTRY { Lab Test - U and E's } CLUSTER { Lab analyte } ELEMENT name { Urea } value { 4.3 mmols/l} CDR - Care Data Repository All of the records within a single namespaced patient data repository. In some environments, a single physical repository may be represented as a number of independent virtual \u2018domains\u2019 each of which can be regarded as a separate CDR. EHR - Electronic Health Record An EHR is the top-level container of all clinical records for a single patient. All of those records are created as Compositions. When a new person/patient is registered with a CDR, a new EHR object is created, generally keyed on some kind of external identifier such as an NHS number, CHI number or other Medical Record identifier (MRI). Folder (optional) A high-level grouping of references to Compositions. A Composition may exist in multiple Folders. For example a patient with Diabetes who is admitted to hospital with a related problem may have any related Compositions tagged as being in both a 'Diabetes Folder' and a Folder specific to that admission. Composition A Composition is a 'document-style' container for all clinical records. This equates to an Encounter, a Lab Report, a Discharge summary, a set of Nursing Observations. All openEHR data is stored within the context of a Composition and always includes standard clinical/medico-legal context information such as clinical author details, encounter times etc. Compositions are versioned and fully-audit trailed, so that previous versions can always be retrieved, if they need to be updated or deleted. The Composition is the container for structured/ coded data with granular clinical statements such as procedure, blood pressure, allergy expressed as an Entry, within which the leaf data is contained in Elements e.g Systolic, Diastolic, Cuff size. Although openEHR information is always stored in the context of a particular Composition, it can always be queried indpendently of that context. Composition versioning openEHR systems handle versioning automatically. Any time a new version of an existing document is committed to the system, its unique compositionId identifier \u2018version suffix\u2019 is updated e.g 798e27b1-f2e8-48c3-8ced-42d4d27d1db3::c4h.hopd.com::1 \u2192 798e27b1-f2e8-48c3-8ced-42d4d27d1db3::c4h.hopd.com::2 In normal operation only the most recent version of the composition is returned by querying or composition retrieval. Section (optional) Sections are optional structures which are used to break up complex openEHR Compositions, grouping the Entries into high-level headings e.g. in a Transfer of Care document, Sections might be represented as Allergies, Problems, Procedures, Lab tests etc. Sections are convenient for human consumption and navigation but should not be used to infer meaning. Entry In openEHR, all of key clinical content is carried within one of the 5 ENTRY sub-classes: Observation Evaluation Instruction Action Admin_entry The Entry is the container for structured/ coded data via granular clinical statements such as Procedure, Blood pressure, Allergy, within which the leaf data is contained in Elements e.g Systolic, Diastolic, Cuff size. Entries are where most recognisable health and care concepts are modelled. THe sub-classes reflect slightly different generic requirements e.g Instructions and Actions carry extra attributes to facilitate the tracking of requests and orders and the activities that follow, whereas Observations often require more complex handling of time and person state. Cluster (optional) A Cluster is a branch-like sub-structure of an ENTRY which allow ELEMENTS to be conveniently grouped and possibly repeated e.g in a Lab Test archetype, data related to a single lab analysis result is grouped within a Cluster to allow the whole pattern to be repeated Lab Test Lab Result (Cluster) - multiple Result Comment Datetime reported Status In the construct above the cluster allows multiple Lab results to be captured within a single Lab Test. Element An Element is the leaf-node construct which is basically a name/value pair with a defined datatype. The nature of the datatype determines the exact structure of the Element.","title":"Overview of openEHR"},{"location":"intro/INT1-overview-openehr/#introduction","text":"openEHR is a non-profit collaborative which promotes an open standards-based person-centric health and care records ecosystem, sometimes referred to as the 'open Platform' approach. It envisages a world where patient/person health and care information is managed coherently in person-centric information stores, independent of the applications that read, write and query the at information. This is quite different from the current norm in healthcare, where thousands of individual applications hold siloed parts of the person's record, in siloed, normally proprietary, logical and physical data formats. Decades of effort have gone into trying to make this 'best-of-breed' approach interoperate, and whilst some positive progress is being made with HL7 FHIR, the limits of 'traditional interoperability are increasingly evident, as the complexity scales-up. The openEHR community believes that traditional interoperability between siloed systems, whilst a necessary part of the story, will not, by itself, deliver the kind of seamless and coherent integration between apps that otherwise has only been possible by acquiring a single, large-scale vendor system, with all of the disadvantages of technical and commercial lock-in that follow. This website also gives a helpful overview of the 'open platform approach' which openEHR is designed to support.openehr-modellinfg","title":"Introduction"},{"location":"intro/INT2-overview-rest-apis/","text":"Introduction Although the basic approach of interacting with openEHR CDRs via a simple service layer has been well established for some time, until recently, each CDR vendor had their own RESTful API, albeit these worked in a very similar fashion. In recent years the CDR implementer community has agreed a common standardised openEHR REST API This has now been implemented by a number of CDR providers, though most continue to make use of their 'proprietary variants' alongside the standard API. This documentation and related technical artefacts will cover the standard openEHR REST API, as well as the equivalent calls to the Better Ehrscape API , which is widely used in the UK, and in particular is supported by the Ripple Ethercis CDR. One significant difference is that Better Ehrscape API allows openEHR records to be submitted via some simplified JSON formats which are very helpful to those new to openEHR. Work is underway to bring this kind of 'simplified JSON' into the openEHR standard space and we also anticipate some other vendors to emulate the Better Ehrscape JSON formats until the standardised simplified format is agreed. To be clear, these simplified formats are used for convenience only, and within the CDR the data is stored and can be retrieved and queried in a completely standard fashion via the openEHR REST API. Differences between Better Ehrscape and openEHR REST APIs Conceptually these APIS are very similar with almost identical REST resources. For example the List templates call in Better Ehrscape is curl --location --request GET 'https://cdr.code4health.org/rest/v1/template' \\ --header 'Accept: application/json' \\ --header 'Authorization: ' while in the openEHR REST API it is curl --location --request GET 'https://cdr.code4health.org/rest/v1/definition/template/adl1.4' \\ --header 'Accept: application/json' \\ --header 'Prefer: return=minimal' \\ --header 'Authorization: ' The basic message is that if you become familiar with the Better Ehrscape API, jumping to, or intermixing with, the openEHR REST API will not be too difficult.","title":"Overview of openEHR REST APIs"},{"location":"intro/INT2-overview-rest-apis/#introduction","text":"Although the basic approach of interacting with openEHR CDRs via a simple service layer has been well established for some time, until recently, each CDR vendor had their own RESTful API, albeit these worked in a very similar fashion. In recent years the CDR implementer community has agreed a common standardised openEHR REST API This has now been implemented by a number of CDR providers, though most continue to make use of their 'proprietary variants' alongside the standard API. This documentation and related technical artefacts will cover the standard openEHR REST API, as well as the equivalent calls to the Better Ehrscape API , which is widely used in the UK, and in particular is supported by the Ripple Ethercis CDR. One significant difference is that Better Ehrscape API allows openEHR records to be submitted via some simplified JSON formats which are very helpful to those new to openEHR. Work is underway to bring this kind of 'simplified JSON' into the openEHR standard space and we also anticipate some other vendors to emulate the Better Ehrscape JSON formats until the standardised simplified format is agreed. To be clear, these simplified formats are used for convenience only, and within the CDR the data is stored and can be retrieved and queried in a completely standard fashion via the openEHR REST API.","title":"Introduction"},{"location":"intro/INT3-archetypes-template/","text":"An openEHR CDR consumes, retrieves and queries patient healthcare data using a standardised open specification and querying format defined by openEHR International . THis provides a way for clinicians to define and share open-source, vendor-neutral clinical information components ( archetypes and templates ) which can be consumed, persisted and queried by different technology stacks, as long as they adhere to the openEHR specifications. Examples of archetypes used in this project are Procedure , Symptom , and Imaging result . These are managed by the openEHR International using the Clinical Knowledge Manager tool and mirrored to Github , with a CC-BY-SA licence. A repository of archetypes and templates designed for UK use is maintained jointly by the Apperta Foundation at Apperta CKM and is mirrored to a Git repository . These make use of many of the archetypes on the international CKM< but have additional UK-specific archetypes and templates, intended to help harmonise use across the 4 UK countries and Ireland. e.g. the 5N CDR project","title":"openEHR archetypes and templates"},{"location":"intro/INT4-reference-model/","text":"The openEHR Reference model defines a relatively small set of information model constructs which openEHR back-ends must support. This includes a number of generic classes and datatypes. The Reference model contains virtually no clinical content e.g concepts for Medication, or Diagnosis. These are defined and managed separately as archetypes . Key openEHR datatypes openEHR has a very rich set of allowable datatypes. A full definition is beyond the scope of this document but developers new to this field may find the following notes helpful. Datatype: text Allows the recording of simple, unformatted text. openEHR does not normally constrain the length of string. asthma_diary_entry/history:0/story_history/comment: Feeling much better, Datatype: codedText Is a commonly used datatype in openEHR systems and is a sub-class of text. i.e where-ever text is specified codedText can be used instead. Codes may be 'external' e.g. SNOMED CT or 'local', where they are defined within archetypes, have the form 'atxxxxx' and are commonly referred to as 'atCodes' A codedText element always includes the terminologyID, the code itself and the text of the coded concept (Rubric). Where a codedText item is required, allowed value(s) are expressed in the form: terminologyId :: code :: rubric local :: at0007 :: Dental swelling SNOMED - CT :: 123456 :: No pathology found When a codedText item is added to a FLAT JSON format document, you must give the code, value and terminology, unless this is a local (atCode) code, in which case only the code needs to be provided. External terminology e.g SNOMED CT Code, terminology and value must be specified 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|code': '23924001', 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|value': 'chest tightness', 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|terminology': 'SNOMED-CT', Local 'atCode' e.g at0007 Only the code needs to be specified - the value and terminology are not required since they are pre-defined in the openEHR template.. 'asthma_diary_entry/examination_findings:0/pulmonary_function_testing:0/result_details/pulmonary_flow_rate_result/test_result_name|code': 'at0071' Datatype: ordinal Combines codedText with a score, expressed as an integer. 0 : Green ` local :: at0022 :: Green ` 1 : Amber ` local :: at0023 :: Amber ` 2 : Red ` local :: at0024 :: Red ` 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|code' : 'at0024' , 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|ordinal' : 2 , 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|value' : 'Red' , Datatype: count count is a simple integer. 'community_dental_final_assessment_letter/investigations_and_results:0/imaging_examination_result:0/result_group/decayed_teeth/decayed_teeth': 4, Datatype: datetime Records a date or date and time using the ISO8061 format . 'ctx/time': '2014-09-23T00:11:02.518+02:00' Datatype: quantity Records a physical quantity along with the appropriate SI units, which should normally be compliant with UCUM . \"asthma_diary_entry/examination_findings:0/pulmonary_function_testing:0/result_details/pulmonary_flow_rate_result/actual_result|magnitude\": 550, \"asthma_diary_entry/examination_findings:0/pulmonary_function_testing:0/result_details/pulmonary_flow_rate_result/actual_result|unit\": \"l/min\", Key openEHR concepts and classes External identifiers The subjectId (sometimes called externalId) is a patient identifier by which the patient is known outwith the openEHR system e.g. a hospital identifier or NHS number. EHR In an openEHR system, each patient has an ehr (a per-patient electronic health record) with a unique ehrId identifier (usually a guid). All references to openEHR patient data are via this ehrId. An API call GET ehr/ is used to reference the ehrId from the provided subjectId/externalId. Example ehrId: 8fa77360-683c-4989-be5e-89a192624b43 Other subsequent calls to the openEHR system for that particular patient are via the ehrId. COMPOSITION All openEHR data is committed inside a composition , a document-level container which is given a unique compositionId . If the composition is subsequently updated the root compositionId remain unchanged but its version number is incremented. All previous composition versions are retained for audit/legal purposes. Initial version 2cf04d6c-31e8-4599-a14b-9a0add4de5d9::fivium.ehrscape.com::1 Revised version 2cf04d6c-31e8-4599-a14b-9a0add4de5d9::fivium.ehrscape.com::2 If you need to retrieve a composition, it is normally ok to simply use the root part 2cf04d6c-31e8-4599-a14b-9a0add4de5d9 which will return the latest revision in the current repository. openEHR Composition file formats In general, committing or retrieving a composition to/from an openEHR system involves sending or receiving a structured XML or JSON file via a simple API. The current standard 'canonical XML' openEHR Composition format is defined by a set of standard schema . More recently, openEHR implementers have started to develop alternative custom JSON formats (usuually with converters to/from the canonical XML format). The Better Ehrscape API ,eveloped by Better, provides a simple restful API which hides much of the complexity of the underlying openEHR server accepting simpler, flatter forms of composition data, using defaults within the template schema to correctly populate the raw openEHR data which is stored internally. The FLAT JSON format is just a set of simple name/value pairs where the 'name' carries the path to each element. You do not need to parse this path. You should normally use this FLAT JSON format, which is easier for new openEHR users. e.g. FLAT JSON format \"community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/clinical_factors|code\": \"at0025\", \u2026 STRUCTURED JSON format \u2026 \"clinical_factors\": [ { \"|code\": \"at0025\", \"|terminology\": \"local\", \"|value\": \"Teeth with carious lesions\" } ] \u2026 RAW XML format \u2026 <ns2:value xsi:type= \"ns2:DV_CODED_TEXT\" > <ns2:value <Teeth with carious lesions</ns2:value > <ns2:defining_code> <ns2:terminology_id> <ns2:value <local</ns2:value > </ns2:terminology_id> <ns2:code_string <at0025</ns2:code_string > </ns2:defining_code> </ns2:value> </ns2:value> \u2026 Key openEHR Reference model attributes A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model. committer This is the name of the person physically committing the document ie. the person logged on to the account. If omitted from API calls, Ehrscape will use the domain login name. composition/composer This is the clinical author of the document i.e the person with clinical responsibility. Ehrscape FLAT and STRCTURTED formats handle this as composer_name . composition/context/start_time This is the time that the clinical interaction with the patient began. Ehrscape FLAT and STRUCTURED formats handle this as ctx/time. composition/context/health_care_facility This is the healthcare facility / oragnisation under who\u2019s remit the encounter took place. observation/time This is the time that a patient\u2019s signs and symptoms were observed or a test was run. It is set automatically by the value of the ctx/time attribute. If you need to set the time of a specific observation you can use The Ehrscape FLAT and STRUCTURED formats hide much of the complexity of these attributes, providing sensible defaults. In particular the ctx header common to both JSON STRUCTURED and FLAT formats, considerably simplifies the composition header \u2026 'ctx/composer_name': 'Rebecca Wassall', 'ctx/health_care_facility|id': '999999-345', 'ctx/health_care_facility|name': 'Northumbria Community NHS', 'ctx/id_namespace': 'NHS-UK', 'ctx/id_scheme': '2.16.840.1.113883.2.1.4.3', 'ctx/language': 'en', 'ctx/territory': 'GB', 'ctx/time': '2014-09-23T00:11:02.518+02:00', Handling specific openEHR datatypes text Text handling is normally straightforward. FLAT + STRUCTURED \"synopsis\": [ \"Significant dental issues.\" ] codedText For an external terminology, the terminologyId, code and text value must be supplied but in JSON FLAT and STRUCTURED formats only the local 'atcode' needs to be supplied. STRUCTURED JSON format Internal (local) code: \"dental_swelling\": [ { \"|code\": \"at0006\", } ] External terminology: \"symptom_name\": [ { \"|code\": \"102616008\", \"|terminology\": \"SNOMED-CT\", \"|value\": \"Painful mouth\" } ] FLAT JSON format Internal (local) code: \"community_dental_final_assessment_letter/examination_findings:0/physical_examination_findings:0/oral_examination/dental_swelling|code\" : \"at0006\" External terminology: \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|value\" : \"Painful mouth\" , \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|code\" : \"102616008\" , \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|terminology\" : \"SNOMED-CT\" ordinal For JSON FLAT and STRUCTURED formats only the local 'atcode' needs to be supplied although the ordinal and text value are also accepted FLAT JSON format \"community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|code\": \"at0024\" STRUCTURED format \"caries_risk\" : [ { \"|code\" : \"at0024\" , } ] or \"caries_risk\" : [ { \"|code\" : \"at0024\" , \"|ordinal\" : 2 , \"|value\" : \"Red\" } ] date Dates need to be persisted in the ISO8061format and should be displayed in CUI format e.g. 12-Nov-1958 Tricky issues Converting UI checkboxes to/from codedText In a number of places, the UI may best be represented as a set of checkboxes, while the underlying data is modelled as codedText. e.g. Symptoms While it may seem more easier and more logical to use a boolean datatype, this is a common pattern in openEHR datasets which are designed to be interoperable and extensible. Experience has shown that expansion of the target valueset and alignment to external terminologies is easier if an enumerated list of codedText is used rather than boolean. In the case of 'Symptom' the rule is \u2026 If the checkbox is ticked, populate the Symptom name with the SNOMED-CT term If the checkbox is unticked, omit the Symptom name element completely. Conversely when loading a persisted dataset, the checkbox should only be checked if the Symptom name element is present and contains SNOMED-CT term 102616008. Multiple occurrence data Some aspects of the form e.g Symptoms are handled as multiple occurrences of the same data point in the underlying dataset.","title":"openEHR Reference Model"},{"location":"intro/INT4-reference-model/#key-openehr-datatypes","text":"openEHR has a very rich set of allowable datatypes. A full definition is beyond the scope of this document but developers new to this field may find the following notes helpful.","title":"Key openEHR datatypes"},{"location":"intro/INT4-reference-model/#key-openehr-concepts-and-classes","text":"","title":"Key openEHR concepts and classes"},{"location":"intro/INT4-reference-model/#key-openehr-reference-model-attributes","text":"A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model.","title":"Key openEHR Reference model attributes"},{"location":"intro/INT4-reference-model/#handling-specific-openehr-datatypes","text":"","title":"Handling specific openEHR datatypes"},{"location":"intro/INT4-reference-model/#tricky-issues","text":"","title":"Tricky issues"},{"location":"opencdr/OCDR1-authentication/","text":"Getting started - Authentication Let's get started by hooking up to an openCDR via the openEHR REST API . This API is now supported by most publicly available CDRs, including Better, DIPS, Code24 and Ehrbase. We have included examples for the Better CDR used by the Apperta Code4Health platform but they have also been tested against the ehrBase CDR. Authentication All of the openCDR API calls require some sort of authentication in the header. In production this is likely to be something like JSON Web Tokens (JWT) but for demo purposes both ehrBase and betterCDR support Basic Auth based on a Username and Password. Basic Authentication If you have a Postman environment file related to your openCDR, you should be able to find the Username and Password, and possibly the Basic Auth token, pre-calculated. If it is not pre-calculated, it is easy to do so with code like this Typescript. const authString = btoa ( ` ${ username } : ${ password } ` ) const authToken = `Basic: ${ authString } ` You then need to send that token in the Authorization header of your REST call e.g. curl --location \\ --request GET 'https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4' \\ --header 'Accept: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' Connecting to the CDR To test our basic connection to the CDR, we will perform a very simple List templates call to list the openEHR templates currently registered with the CDR -> Working with openEHR Templates","title":"Getting started - Authentication"},{"location":"opencdr/OCDR1-authentication/#getting-started-authentication","text":"Let's get started by hooking up to an openCDR via the openEHR REST API . This API is now supported by most publicly available CDRs, including Better, DIPS, Code24 and Ehrbase. We have included examples for the Better CDR used by the Apperta Code4Health platform but they have also been tested against the ehrBase CDR.","title":"Getting started - Authentication"},{"location":"opencdr/OCDR2-openehr-templates/","text":"Working with openEHR Templates openEHR templates are aggregations of logical archetype models that along with the basic Reference model, act as the validation schema for any patient data submitted to the CDR. This section will test our connection the CDR by running a List templates call, then upload a new template to the CDR via an Upload a template call A. List templates cURL curl --locations --request GET 'https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4' \\ --header 'Accept: application/json' \\ --header 'Prefer: return=minimal' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4' , headers : { 'Accept' : 'application/json' , 'Prefer' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4\" payload = {} headers = { 'Accept' : 'application/json' , 'Prefer' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response If your CDR is already provisioned with some templates, you will a 200 code and some output like this. [ { \"concept\" : \"IDCR - Vital Signs Encounter.v1\" , \"template_id\" : \"IDCR - Vital Signs Encounter.v1\" , \"archetype_id\" : \"openEHR-EHR-COMPOSITION.encounter.v1\" , \"created_timestamp\" : \"2020-06-26T17:03:11.518Z\" }, { \"concept\" : \"DENWIS_Observations\" , \"template_id\" : \"DENWIS_Observations\" , \"archetype_id\" : \"openEHR-EHR-COMPOSITION.encounter.v1\" , \"created_timestamp\" : \"2020-06-29T11:26:33.055Z\" }, { \"concept\" : \"Suspected Covid-19 Assessment.v0.1\" , \"template_id\" : \"Suspected Covid-19 Assessment.v0.1\" , \"archetype_id\" : \"openEHR-EHR-COMPOSITION.encounter.v1\" , \"created_timestamp\" : \"2020-07-06T14:24:33.974Z\" } ] otherwise you should get a 200 code and an empty array. If you get some other error, this is likely to be that you have not set the baseURL correctly, or that the Authorization token is incorrect. B. Upload a new template You will find an example 'operational' template here in the templates folder. This example is for a simple data-entry dataset to allow patients to record how they are feeling, and then share this with their care team. Don't worry for now about the format of the file itself. It follows the Archetype Object Model (1.4) but is always generated automatically by tools such as the openEHR Archetype Designer. cURL curl --location --request POST 'https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4' \\ --header 'Accept: application/xml' \\ --header 'Content-Type: application/xml' \\ --header 'Prefer: return=minimal' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' \\ --data-raw '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <template xmlns=\"http://schemas.openehr.org/v1\"> <language> <terminology_id> <value>ISO_639-1</value> </terminology_id> <code_string>en</code_string> </language> <description> .... // Snipped for brevity // </template> ' NodeJS axios var axios = require ( 'axios' ); var data = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n<template xmlns=\"http://schemas.openehr.org/v1\">\\n <language>\\n <terminology_id>\\n <value>ISO_639-1</value>\\n </terminology_id>\\n <code_string>en</code_string>\\n </language>\\n <description>\\n <original_author id=\"name\">Ian McNicoll</original_author>\\n <original_author id=\"organisation\">freshEHR Clinical Informatics Ltd.</original_author>\\n <original_author id=\"email\">ian@freshehr.com</original_author>\\n <original_author id=\"date\">2020-02-27</original_author>\\n <lifecycle_state>release_candidate</lifecycle_state>\\n <other_details id=\"licence> TRIMMED for Brevity...... </template>\\n' ; var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/openehr/v1/definition/template/adl1.4' , headers : { 'Accept' : 'application/json' , 'Content-Type' : 'application/xml' , 'PREFER' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"/definition/template/adl1.4\" payload = \"<?xml version= \\\" 1.0 \\\" encoding= \\\" utf-8 \\\" ?> \\n <!--Operational template XML automatically generated by Ocean Template Designer Version 2.8.94Beta--> \\n <template xmlns:xsi= \\\" http://www.w3.org/2001/XMLSchema-instance \\\" xmlns:xsd= \\\" http://www.w3.org/2001/XMLSchema \\\" xmlns= \\\" http://schemas.openehr.org/v1 \\\" > \\n <language> \\n <terminology_id> \\n <value>ISO_639-1</value> \\n </terminology_id> \\n <code_string>en</code_string> \\n </language> \\n <description> \\n <original_author id= \\\" Original Author \\\" >Not Specified</original_author> \\n <lifecycle_state>Initial</lifecycle_state> \\n <other_details id= \\\" MetaDataSet:Sample Set \\\" >Template metadata sample set </other_details> \\n <other_details id= \\\" Acknowledgements \\\" ></other_details> \\n <other_details id= \\\" Business Process Level \\\" ></other_details> \\n <other_details id= \\\" Care setting \\\" ></other_details> \\n <other_details id= \\\" Client group \\\" ></other_details> \\n <other_details id= \\\" Clinical Record Element \\\" ></other_details> \\n <other_details id= \\\" Copyright \\\" ></other_details> \\n <other_details id= \\\" Issues \\\" ></other_details> \\n <other_details id= \\\" Owner \\\" ></other_details> \\n <other_details id= \\\" Sign off \\\" ></other_details> \\n <other_details id= \\\" Speciality \\\" ></other_details> \\n ... Snipped for brevity ... \\n </template>\" headers = { 'Accept' : 'application/xml' , 'Content-Type' : 'application/xml' , 'PREFER' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response Currently the response for a successful upload is a little inconsistent between CDRs. ehrBase will give a 204 no response code but the upload has been successful. BetterCDR will give a 201 response code. Overwriting an existing template The current REST specification prohibits overwriting an existing template - issuing a 409 conflict code and while this makes sense for deployments it has proven to be over-restrictive during early development where a template may change repeatedly. BetterCDR allows templates to be over-written and simply returns a 201 code. ehrBase prohibits template over-writing by default but does allow a server configuration to be set which loosens this restriction. More on templates As well as being used to validate patient records when they are committed to the CDR, templates are used as the basis for many other types of technical artefact, such as automatic forms builders, class library generation, and for client-side validation in UI. Although formally aligned with the in-memory AOM, the operational template can be hard to parse and understand, particularly if you are just trying to understand the various schema constraints. For this purpose, you may find it helpful to gnerate a 'Web template' - this is a much simpler JSON format, itself based on the operational template, and which can be exported from the openEHR Archetype Designer via the Export menu. Now that we have a valid template uploaded, we can Commit a Composition of patient data to the CDR.","title":"Working with openEHR Templates"},{"location":"opencdr/OCDR2-openehr-templates/#working-with-openehr-templates","text":"openEHR templates are aggregations of logical archetype models that along with the basic Reference model, act as the validation schema for any patient data submitted to the CDR. This section will test our connection the CDR by running a List templates call, then upload a new template to the CDR via an Upload a template call","title":"Working with openEHR Templates"},{"location":"opencdr/OCDR3-committing-a-composition/","text":"Committing Observation data All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference model schema. If the data is valid, it will be stored in the CDR and is allocated a unique ID, which is returned by the POST /composition call This section will submit an example Composition to the CDR by running a POST / composition call. A number of data serialisation options, can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON or XML formats. Note Note that this example uses the Better Better Ehrscape API which has a slightly different base URL and parameters than the openEHR REST API ,though the data is stored identically and can be accessed from both end points. Ehrscape POST /composition example Parameters ehrId : This is is the internal CDR identifier for a specific patient. When a patient is registered with the CDR,an EHR object is created with a unique ehr_id identifier, and is associated with an external subjectId and subjectNamespace e.g an NHS Number, CHI number, or a local hospital number. We will find out how to work out the correct ehrId for a patient in the next section. Generally when you first open a patient record session, you will retrieve their ehrId via their subjectID and subjectNamespace . We will explain how to do that in the next section. For testing purposes, you should use a known ehrId . If you have a Postman environment file, an example will be in there, otherwise you can find out how to identify valid ehrIds here templateId : This is the identifier of the openEHR template, against which you need to validate the composition. Use DHI - Urology_PROMs-v0 for this example. format : This defines the format of JSON or XML that you are sending. Use FLAT for this example. A. Commit an openEHR Composition ( FLAT JSON ) cURL curl --location --request POST '/composition?ehrId=&templateId=&format=STRUCTURED' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' \\ --data-raw '{ \"{ \"passport_observations/context/start_time\": \"2020-10-18T16:16:21.449Z\", \"passport_observations/context/setting|code\": \"238\", \"passport_observations/context/setting|value\": \"other care\", \"passport_observations/context/setting|terminology\": \"openehr\", \"passport_observations/blood_pressure/systolic|magnitude\": 169.0, \"passport_observations/blood_pressure/systolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/diastolic|magnitude\": 692.0, \"passport_observations/blood_pressure/diastolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/time\": \"2020-10-18T16:16:21.452Z\", \"passport_observations/blood_pressure/language|code\": \"en\", \"passport_observations/blood_pressure/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_pressure/encoding|code\": \"UTF-8\", \"passport_observations/blood_pressure/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/height_length/height_length|magnitude\": 609.33, \"passport_observations/height_length/height_length|unit\": \"cm\", \"passport_observations/height_length/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/height_length/language|code\": \"en\", \"passport_observations/height_length/language|terminology\": \"ISO_639-1\", \"passport_observations/height_length/encoding|code\": \"UTF-8\", \"passport_observations/height_length/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_weight/weight|magnitude\": 380.49, \"passport_observations/body_weight/weight|unit\": \"kg\", \"passport_observations/body_weight/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/body_weight/language|code\": \"en\", \"passport_observations/body_weight/language|terminology\": \"ISO_639-1\", \"passport_observations/body_weight/encoding|code\": \"UTF-8\", \"passport_observations/body_weight/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/blood_glucose/test_name|code\": \"14743-9\", \"passport_observations/blood_glucose/test_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/test_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|code\": \"14743-9\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|magnitude\": 52.61, \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|unit\": \"mmol/L\", \"passport_observations/blood_glucose/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/blood_glucose/language|code\": \"en\", \"passport_observations/blood_glucose/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_glucose/encoding|code\": \"UTF-8\", \"passport_observations/blood_glucose/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/pulse_oximetry/spo|numerator\": 0.0, \"passport_observations/pulse_oximetry/spo|denominator\": 100.0, \"passport_observations/pulse_oximetry/spo|type\": 2, \"passport_observations/pulse_oximetry/spo\": 0.0, \"passport_observations/pulse_oximetry/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/pulse_oximetry/language|code\": \"en\", \"passport_observations/pulse_oximetry/language|terminology\": \"ISO_639-1\", \"passport_observations/pulse_oximetry/encoding|code\": \"UTF-8\", \"passport_observations/pulse_oximetry/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_temperature/temperature|magnitude\": 72.7, \"passport_observations/body_temperature/temperature|unit\": \"[degF]\", \"passport_observations/body_temperature/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/body_temperature/language|code\": \"en\", \"passport_observations/body_temperature/language|terminology\": \"ISO_639-1\", \"passport_observations/body_temperature/encoding|code\": \"UTF-8\", \"passport_observations/body_temperature/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/clinical_synopsis/notes\": \"Notes 9\", \"passport_observations/clinical_synopsis/language|code\": \"en\", \"passport_observations/clinical_synopsis/language|terminology\": \"ISO_639-1\", \"passport_observations/clinical_synopsis/encoding|code\": \"UTF-8\", \"passport_observations/clinical_synopsis/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/category|code\": \"433\", \"passport_observations/category|value\": \"event\", \"passport_observations/category|terminology\": \"openehr\", \"passport_observations/language|code\": \"en\", \"passport_observations/language|terminology\": \"ISO_639-1\", \"passport_observations/territory|code\": \"JM\", \"passport_observations/territory|terminology\": \"ISO_3166-1\" }' NodeJS + Axios ```js var axios = require ( 'axios' ); var data = JSON . stringify ( { \"prostate_cancer_proms_report\" : // trimmed for brevity }\" ); var config = { method : 'post' , url : '/composition?ehrId=&templateId=&format=STRUCTURED' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : '' } , data : data } ; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); } ) . catch ( function ( error ) { console . log ( error ); } ); ``` Response for POST /composition { \"meta\" : { \"href\" : \"https://cdr.code4health.org/rest/v1/composition/59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" }, \"action\" : \"CREATE\" , \"compositionUid\" : \"59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" } The Composition Id The compositionUid is the unique identifier allocated to (and held within) every composition by the CDR. You will see that it ends in ...::1 . The 1 is the version of this composition instance. If you need to update the instance (perhaps because of an error), you need to do so via a PUT / composition call and if successful the composition version number will clock up to ::2 . In essence every commit is versioned and retained for medico-legal reasons. Similarly when a composition is deleted, this is a logical delete and the composition can always be retrieved, though is not normally accessible via querying. We will go through the process of updating a composition later. For now let's just retrieve the composition we just committed, via the GET /composition call.","title":"Committing Observation data"},{"location":"opencdr/OCDR3-committing-a-composition/#committing-observation-data","text":"All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference model schema. If the data is valid, it will be stored in the CDR and is allocated a unique ID, which is returned by the POST /composition call This section will submit an example Composition to the CDR by running a POST / composition call. A number of data serialisation options, can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON or XML formats. Note Note that this example uses the Better Better Ehrscape API which has a slightly different base URL and parameters than the openEHR REST API ,though the data is stored identically and can be accessed from both end points.","title":"Committing Observation data"},{"location":"opencdr/OCDR4-retrieving-a-composition/","text":"Retrieving an openEHR Composition All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better FLAT JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish. Better Ehrscape GET /composition example Parameters compositionId : This is is the composition UID for the composition you wish to retrieve. Don't worry about how we find that out for now. Just use the UID for the composition you just committed in the last section. We will find out how to find compositionIds in a subsequent section. format : This defines the format of JSON or XML that you are requesting. Use FLAT for this example. A. Retrieve an openEHR Composition ( FLAT JSON ) cURL bash curl --location --request GET '/composition/?format=FLAT' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' NodeJS + Axios ```js var axios = require('axios'); var config = { method: 'get', url: '/composition/?format=STRUCTURED', headers: { 'Content-Type': 'application/json', 'Authorization': '' } }; axios(config) .then(function (response) { console.log(JSON.stringify(response.data)); }) .catch(function (error) { console.log(error); }); ### Response for GET /composition If the composition is found a `200` code will be returned along with the composition object , which you will note now includes the uid, but should otherwise be identical to that which you previously submitted. ```json { \"meta\": { \"href\": \"https://cdr.code4health.org/rest/v1/composition/7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" }, \"compositionUid\": \"7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"format\": \"FLAT\", \"templateId\": \"JMOHW - Passport observations.v0\", \"composition\": { \"passport_observations/_uid\": \"7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"passport_observations/language|code\": \"en\", \"passport_observations/language|terminology\": \"ISO_639-1\", \"passport_observations/territory|code\": \"JM\", \"passport_observations/territory|terminology\": \"ISO_3166-1\", \"passport_observations/context/start_time\": \"2020-10-18T16:16:21.449Z\", \"passport_observations/context/setting|code\": \"238\", \"passport_observations/context/setting|value\": \"other care\", \"passport_observations/context/setting|terminology\": \"openehr\", \"passport_observations/blood_pressure/systolic|magnitude\": 169.0, \"passport_observations/blood_pressure/systolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/diastolic|magnitude\": 692.0, \"passport_observations/blood_pressure/diastolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/time\": \"2020-10-18T16:16:21.452Z\", \"passport_observations/blood_pressure/language|code\": \"en\", \"passport_observations/blood_pressure/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_pressure/encoding|code\": \"UTF-8\", \"passport_observations/blood_pressure/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/height_length/height_length|magnitude\": 609.33, \"passport_observations/height_length/height_length|unit\": \"cm\", \"passport_observations/height_length/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/height_length/language|code\": \"en\", \"passport_observations/height_length/language|terminology\": \"ISO_639-1\", \"passport_observations/height_length/encoding|code\": \"UTF-8\", \"passport_observations/height_length/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_weight/weight|magnitude\": 380.49, \"passport_observations/body_weight/weight|unit\": \"kg\", \"passport_observations/body_weight/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/body_weight/language|code\": \"en\", \"passport_observations/body_weight/language|terminology\": \"ISO_639-1\", \"passport_observations/body_weight/encoding|code\": \"UTF-8\", \"passport_observations/body_weight/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/blood_glucose/test_name|code\": \"14743-9\", \"passport_observations/blood_glucose/test_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/test_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|code\": \"14743-9\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|magnitude\": 52.61, \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|unit\": \"mmol/L\", \"passport_observations/blood_glucose/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/blood_glucose/language|code\": \"en\", \"passport_observations/blood_glucose/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_glucose/encoding|code\": \"UTF-8\", \"passport_observations/blood_glucose/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/pulse_oximetry/spo|numerator\": 0.0, \"passport_observations/pulse_oximetry/spo|denominator\": 100.0, \"passport_observations/pulse_oximetry/spo|type\": 2, \"passport_observations/pulse_oximetry/spo\": 0.0, \"passport_observations/pulse_oximetry/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/pulse_oximetry/language|code\": \"en\", \"passport_observations/pulse_oximetry/language|terminology\": \"ISO_639-1\", \"passport_observations/pulse_oximetry/encoding|code\": \"UTF-8\", \"passport_observations/pulse_oximetry/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_temperature/temperature|magnitude\": 72.7, \"passport_observations/body_temperature/temperature|unit\": \"[degF]\", \"passport_observations/body_temperature/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/body_temperature/language|code\": \"en\", \"passport_observations/body_temperature/language|terminology\": \"ISO_639-1\", \"passport_observations/body_temperature/encoding|code\": \"UTF-8\", \"passport_observations/body_temperature/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/clinical_synopsis/notes\": \"Notes 9\", \"passport_observations/clinical_synopsis/language|code\": \"en\", \"passport_observations/clinical_synopsis/language|terminology\": \"ISO_639-1\", \"passport_observations/clinical_synopsis/encoding|code\": \"UTF-8\", \"passport_observations/clinical_synopsis/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/category|code\": \"433\", \"passport_observations/category|value\": \"event\", \"passport_observations/category|terminology\": \"openehr\", \"passport_observations/composer|name\": \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\" }, \"deleted\": false, \"lastVersion\": true, \"ehrId\": \"b4a4577f-7496-4053-ae60-45e22cfc9952\", \"lifecycleState\": \"COMPLETE\" }``` #### Other data formats The Better Ehrscape API offers several other serialisation formats. You can have a look at these by simply changing the `format` parameter on the `GET / composition` call, and the call Header `Accept` to switch between JSON and XML. ##### 'FLAT JSON' This uses the same path-shortening mechanism as structured JSON but flattens all of the tree structure to a set of name-value pairs. Some developers prefer this to the STRUCTURED format. format=FLAT Accept : `application/json' ##### 'RAW JSON' This is very similar to, but not identical to the openEHR Canonical JSON format, which essentially supercedes it. It very closely adheres tothe openEHR Reference model specification but is pretty voluminous format=RAW Accept : application/json' ##### 'RAW XML' This is 'canonical' openEHR XML which is also accepted by the openEHR REST API. It is the lingu-franca for all openEHR CDRs, even thosewhich do not support the REST CDR API, will normally accept and expose data in this XML format. format=RAW Accept : application/xml' ```","title":"Retrieving an openEHR Composition"},{"location":"opencdr/OCDR4-retrieving-a-composition/#retrieving-an-openehr-composition","text":"All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better FLAT JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish.","title":"Retrieving an openEHR Composition"},{"location":"opencdr/OCDR5-creating-an-ehr/","text":"Creating a new patient 'EHR' When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. NHS number, CHI number in the UK) or hospital MRI) is submitted by a POST /ehr | create EHR call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Depending on your local governance environment, you may/ may not be allowed to create new EHRs . openCDR POST /ehr - Create an EHR from SubjectId/subjectNamespace example Parameters subjectId This is the external identifier by which the patient is known within the CDR. It is normally a real-word identifier like an NHS number, CHI number or Hospital 'MRI' number, and will have been supplied to the CDR when the patients' EHR object was created in the datastore. Example value : 9999999000 subjectNamespace This is just a unique string used to identify the numbering scheme used for the 'subjectId'. It will commonly be some sort of URI such as uk.nhs.nhs_number and will have been agreed at national level. Example value : uk.nhs.nhs_number Postman cURL curl --location \\ --request GET 'https://cdr.code4health.org/rest/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' NodeJs - Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://cdr.code4health.org/rest/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://cdr.code4health.org/rest/v1/ehr/?subjectId=9999999000&subjectNamespace=uk.nhs.nhs_number\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response Better CDR will give a 200 response code and this structure. { \"meta\" : { \"href\" : \"https://cdr.code4health.org/rest/v1/ehr/3e674739-950c-4b8a-976b-5aef21c618c5\" }, \"ehrStatus\" : { \"subjectId\" : \"9999999000\" , \"subjectNamespace\" : \"uk.nhs.nhs_number\" , \"queryable\" : true , \"modifiable\" : true , \"otherDetails\" : { \"@class\" : \"ITEM_TREE\" , \"items\" : [ { \"@class\" : \"CLUSTER\" , \"archetype_details\" : { \"@class\" : \"ARCHETYPED\" , \"archetype_id\" : { \"@class\" : \"ARCHETYPE_ID\" , \"value\" : \"openEHR-EHR-CLUSTER.person_anonymised_parent.v1\" }, \"rm_version\" : \"1.0.1\" }, \"archetype_node_id\" : \"openEHR-EHR-CLUSTER.person_anonymised_parent.v1\" , \"items\" : [ { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Administrative Gender\" }, \"archetype_node_id\" : \"at0001\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Male\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0009\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Birth Sex\" }, \"archetype_node_id\" : \"at0002\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Male\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0009\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Vital Status\" }, \"archetype_node_id\" : \"at0003\" , \"value\" : { \"@class\" : \"DV_CODED_TEXT\" , \"value\" : \"Alive\" , \"defining_code\" : { \"@class\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"@class\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0004\" } } }, { \"@class\" : \"ELEMENT\" , \"name\" : { \"@class\" : \"DV_TEXT\" , \"value\" : \"Birth Year\" }, \"archetype_node_id\" : \"at0014\" , \"value\" : { \"@class\" : \"DV_DATE\" , \"value\" : \"1944\" } } ] } ] } }, \"ehrId\" : \"3e674739-950c-4b8a-976b-5aef21c618c5\" } The only datapoint you need to retrieve is ehrId . Hint You may want to consider caching this for the session, so that it can be used for a number of subsequent calls.","title":"Creating a new patient 'EHR'"},{"location":"opencdr/OCDR5-creating-an-ehr/#creating-a-new-patient-ehr","text":"When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. NHS number, CHI number in the UK) or hospital MRI) is submitted by a POST /ehr | create EHR call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Depending on your local governance environment, you may/ may not be allowed to create new EHRs .","title":"Creating a new patient 'EHR'"},{"location":"opencdr/OCDR6-retrieving-an-ehrid/","text":"Retrieving the patient's ehrId When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. NHS number, CHI number in the UK) or hospital MRI) is submitted by a POST /ehr | create EHR from SubjectId call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Most openCDR API calls require an 'ehrId' to identify the correct patient, so normally the first activity required if interacting with a patient record is to retrieve their ehrId , and then often to cache that identifier so it can be used for subsequent calls, until a new patient is being accessed. GET /ehr - retrieve ehr from subjectId/subjectNamespace Parameters subjectId This is the external identifier by which the patient is known within the CDR. It is normally a real-word identifier like an NHS number, CHI number or Hospital 'MRI' number, and will have been supplied to the CDR when the patients' EHR object was created in the datastore. Example value : 9999999000 subjectNamespace This is just a unique string used to identify the numbering scheme used for the subjectId . It will commonly be some sort of URI such as uk_nhs_nhs_number and will have been agreed at national level. Example value : uk_nhs_nhs_number Postman cURL --curl location \\ --request GET '/ehr/?subjectId=https://rest.ehrscape.com/rest/openehr/v19999999000&subjectNamespace=uk.nhs.nhs_number' \\ --header 'Content-Type: application/json' \\ --header 'Accept: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' --header 'PREFER: return=minimal' \\ NodeJs - Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://rest.ehrscape.com/rest/openehr/v1/ehr?subject_id=9999999000&subject_namespace=uk.nhs.nhs_number' , headers : { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' , 'PREFER' : 'return=minimal' , 'Authorization' : Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ == ' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://rest.ehrscape.com/rest/openehr/v1/ehr?subject_id=9999999000&subject_namespace=uk.nhs.nhs_number\" payload = {} headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' , 'PREFER' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response An openCDR will give a 200 response code and this structure. The ehrId that you need to capture is ehr_id.value item in the response. Hint You may want to consider caching this for the session, so that it can be used for a number of subsequent calls. { \"_type\" : \"EHR\" , \"system_id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"4cce5a07-be4d-4318-a94f-3b8401853a20\" }, \"ehr_id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"5dd03bc9-4419-4981-8798-ff4dda8ee9de\" }, \"time_created\" : { \"_type\" : \"DV_DATE_TIME\" , \"value\" : \"2020-07-21T09:00:24.977Z\" }, \"ehr_status\" : { \"_type\" : \"EHR_STATUS\" , \"uid\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"09bcd903-1565-44db-9087-2ff5e5bc7194::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" }, \"subject\" : { \"_type\" : \"PARTY_SELF\" , \"external_ref\" : { \"_type\" : \"PARTY_REF\" , \"id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"9999999000\" }, \"namespace\" : \"uk.nhs.nhs_number\" } }, \"is_queryable\" : true , \"is_modifiable\" : true } }","title":"Retrieving the patient's ehrId"},{"location":"opencdr/OCDR6-retrieving-an-ehrid/#retrieving-the-patients-ehrid","text":"When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. NHS number, CHI number in the UK) or hospital MRI) is submitted by a POST /ehr | create EHR from SubjectId call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Most openCDR API calls require an 'ehrId' to identify the correct patient, so normally the first activity required if interacting with a patient record is to retrieve their ehrId , and then often to cache that identifier so it can be used for subsequent calls, until a new patient is being accessed.","title":"Retrieving the patient's ehrId"},{"location":"opencdr/OCDR7-querying-allergies/","text":"Querying for patient allergies This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT SELECT c / uid / value as compositionId , j / data [ at0001 ] / items [ at0002 ] / value / value as allergy_name , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / code_string as allergy_code , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / terminology_id / value as allergy_terminology , j / data [ at0001 ] / items [ at0009 ] / items [ at0011 ] / value as manifestation , j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value as onset FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c CONTAINS EVALUATION j [ openEHR - EHR - EVALUATION . adverse_reaction_risk . v1 ] ORDER BY j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. { \"meta\" : { \"_type\" : \"RESULTSET\" , \"_created\" : \"2020-10-18T15:28:31.403Z\" , \"_executed_aql\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" }, \"q\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" , \"columns\" : [ { \"name\" : \"compositionId\" , \"path\" : \"/uid/value\" }, { \"name\" : \"allergy_name\" , \"path\" : \"/data[at0001]/items[at0002]/value/value\" }, { \"name\" : \"allergy_code\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/code_string\" }, { \"name\" : \"allergy_terminology\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/terminology_id/value\" }, { \"name\" : \"manifestation\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0011]/value\" }, { \"name\" : \"onset\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0027]/value\" } ], \"rows\" : [ [ \"b960a98f-f799-4f98-b8f1-a3e86e33035e::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Peniccilin\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Tetracycline\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Erythromicin\" , null , null , null , null ] ] }","title":"Querying for patient allergies"},{"location":"opencdr/OCDR7-querying-allergies/#querying-for-patient-allergies","text":"This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc)","title":"Querying for patient allergies"},{"location":"opencdr/OCDR8-querying-compositions/","text":"Querying for recent compositions This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT c / uid / value as compositionId , c / name / value as compositionName , c / context / start_time / value as startTime , c / composer / name as authorName , c / context / health_care_facility / name as facilityName FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c ORDER BY c / context / start_time / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. json { \"meta\": { \"_type\": \"RESULTSET\", \"_created\": \"2020-10-18T15:46:37.208Z\", \"_executed_aql\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\" }, \"q\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\", \"columns\": [ { \"name\": \"compositionId\", \"path\": \"/uid/value\" }, { \"name\": \"compositionName\", \"path\": \"/name/value\" }, { \"name\": \"startTime\", \"path\": \"/context/start_time/value\" }, { \"name\": \"authorName\", \"path\": \"/composer/name\" }, { \"name\": \"facilityName\", \"path\": \"/context/health_care_facility/name\" } ], \"rows\": [ [ \"687d40df-57d1-4d29-ab41-88396f810de0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"Passport observations\", \"2020-10-13T14:31:17.878Z\", \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\", null ], [ \"845db76d-cf06-4fca-9b62-22a7c231f31b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"NCD - first visit\", \"2020-07-22T15:17:03.696Z\", \"Dr Murphy\", null ] ] }","title":"Querying for recent compositions"},{"location":"opencdr/OCDR8-querying-compositions/#querying-for-recent-compositions","text":"This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility","title":"Querying for recent compositions"},{"location":"passport/JPASS1-passport-project-overview/","text":"Overview of the Passport-JDP project This section covers some examples that are very specific to the JMoHW Passport project. The proposed JMoHW Data Platform (JDP) will be based on an openEHR CDR, which is simulated for this project by a sandbox environment provided by the Apperta UK non-profit, and based on the Better CDR product. This is free to use for demonstration purposes and dummy patient data. The initial CDR dataset is aligned to the needs of Non-communicable disease management, including the data handled by Passport. As well as the Passport app demonstrator, a very simple web-based prototype app will be built to simulate a clinician-facing app, making use of the same CDR and able to access/visualise the data submitted to and received from the Passport app. Better Ehrscape API vs. openCDR API usage Most of the calls are based on the 'canonical openEHR REST API which we wil refer to as the 'openCDR' API, other than calls to the /composition resource. Calls to the /composition resource are currently set to make use of the Better Ehrscape API, as the openCDR API does not currently support the FLAT JSON data formats that we will be using. This support is under development e.g by EhrBase and will require only a minor change when implemented. The demonstrator use-cases for Passport are ... 1. Retrieve key sets of read-only data from the CDR Access a patient record from the JDP sandbox via the openEHR query mechanism (AQL). The initial proposed queries are Current allergies Current and recent medications Immunisations Current problems/diagnoses Hospitalisations Recent additions to the CDR record (date, name of clinical author, name of document etc). Final exact details to be discussed with JMoHW but the principles will not change. Technical Tasks Retrieve the patient JDP ehrId from their subjectId - Retrieving the patient's ehrID run an AQL query to find a list of current Allergies and display the queried data - Querying JDP Allergies . run an AQL query to find a list of current Medications (if it exists) and display the queried data - Querying JDP Medication . run an AQL query to find a list of Hospitalizations and display the queried data) - Querying JDP Hospitalization . run an AQL query to find a list of Immunization and display the queried data) - Querying JDP Immunization . run an AQL query to find a list of recently created Compositions and display the queried data) - Querying JDP recent Compositions . run an AQL query to find a list of Diagnoses and display the queried data) - Querying JDP Diagnoses . 2. Work with Patient-derived Observations data Allow patient to enter some simple observational data via their PHR app (Passport) and have it stored in the JDP-CDR. Also display all recent Observation data (however committed) via a query to the JDP-CDR. Technical Tasks Retrieve the patient JDP ehrId from their SubjectId - Retrieving the patient's ehrID . Commit a composition to the JDP-CDR via a composition (FLAT format) - Committing patient Observations . Retrieve that composition - retrieving patient Observations . Query all recent Observation data, including that recorded on the JDP by other applications. Better Ehrscape API vs. openEHR REST API For now, we will make use of the Better Ehrscape API for the /composition calls, rather than the openCDR API, even though the latter is what will be used by the actual JDP-CDR. The primary reason is that, right now, Better support some simplified data formats which are easier for third-party vendors to work with. We know that ehrBase is actively working on support for these formats, and an early release is imminent, so this advice may change. We will supply some documentation to show how, once committed, the same data can be accessed and queried via the openEHR REST API.","title":"Overview of the Passport-JDP project"},{"location":"passport/JPASS1-passport-project-overview/#overview-of-the-passport-jdp-project","text":"This section covers some examples that are very specific to the JMoHW Passport project. The proposed JMoHW Data Platform (JDP) will be based on an openEHR CDR, which is simulated for this project by a sandbox environment provided by the Apperta UK non-profit, and based on the Better CDR product. This is free to use for demonstration purposes and dummy patient data. The initial CDR dataset is aligned to the needs of Non-communicable disease management, including the data handled by Passport. As well as the Passport app demonstrator, a very simple web-based prototype app will be built to simulate a clinician-facing app, making use of the same CDR and able to access/visualise the data submitted to and received from the Passport app. Better Ehrscape API vs. openCDR API usage Most of the calls are based on the 'canonical openEHR REST API which we wil refer to as the 'openCDR' API, other than calls to the /composition resource. Calls to the /composition resource are currently set to make use of the Better Ehrscape API, as the openCDR API does not currently support the FLAT JSON data formats that we will be using. This support is under development e.g by EhrBase and will require only a minor change when implemented. The demonstrator use-cases for Passport are ...","title":"Overview of the Passport-JDP project"},{"location":"passport/JPASS10-retrieving-observation-data/","text":"Retrieving a Patient Observations Composition All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better FLAT JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish. Better Ehrscape GET /composition example Parameters compositionId : This is is the composition UID for the composition you wish to retrieve. Don't worry about how we find that out for now. Just use the UID for the composition you just committed in the last section. We will find out how to find compositionIds in a subsequent section. format : This defines the format of JSON or XML that you are requesting. Use FLAT for this example. A. Retrieve an openEHR Composition ( FLAT JSON ) cURL bash curl --location --request GET '/composition/?format=FLAT' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' NodeJS + Axios ```js var axios = require('axios'); var config = { method: 'get', url: '/composition/?format=STRUCTURED', headers: { 'Content-Type': 'application/json', 'Authorization': '' } }; axios(config) .then(function (response) { console.log(JSON.stringify(response.data)); }) .catch(function (error) { console.log(error); }); ### Response for GET /composition If the composition is found a `200` code will be returned along with the composition object , which you will note now includes the uid, but should otherwise be identical to that which you previously submitted. ```json { \"meta\": { \"href\": \"https://cdr.code4health.org/rest/v1/composition/7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" }, \"compositionUid\": \"7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"format\": \"FLAT\", \"templateId\": \"JMOHW - Passport observations.v0\", \"composition\": { \"passport_observations/_uid\": \"7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"passport_observations/language|code\": \"en\", \"passport_observations/language|terminology\": \"ISO_639-1\", \"passport_observations/territory|code\": \"JM\", \"passport_observations/territory|terminology\": \"ISO_3166-1\", \"passport_observations/context/start_time\": \"2020-10-18T16:16:21.449Z\", \"passport_observations/context/setting|code\": \"238\", \"passport_observations/context/setting|value\": \"other care\", \"passport_observations/context/setting|terminology\": \"openehr\", \"passport_observations/blood_pressure/systolic|magnitude\": 169.0, \"passport_observations/blood_pressure/systolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/diastolic|magnitude\": 692.0, \"passport_observations/blood_pressure/diastolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/time\": \"2020-10-18T16:16:21.452Z\", \"passport_observations/blood_pressure/language|code\": \"en\", \"passport_observations/blood_pressure/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_pressure/encoding|code\": \"UTF-8\", \"passport_observations/blood_pressure/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/height_length/height_length|magnitude\": 609.33, \"passport_observations/height_length/height_length|unit\": \"cm\", \"passport_observations/height_length/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/height_length/language|code\": \"en\", \"passport_observations/height_length/language|terminology\": \"ISO_639-1\", \"passport_observations/height_length/encoding|code\": \"UTF-8\", \"passport_observations/height_length/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_weight/weight|magnitude\": 380.49, \"passport_observations/body_weight/weight|unit\": \"kg\", \"passport_observations/body_weight/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/body_weight/language|code\": \"en\", \"passport_observations/body_weight/language|terminology\": \"ISO_639-1\", \"passport_observations/body_weight/encoding|code\": \"UTF-8\", \"passport_observations/body_weight/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/blood_glucose/test_name|code\": \"14743-9\", \"passport_observations/blood_glucose/test_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/test_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|code\": \"14743-9\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|magnitude\": 52.61, \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|unit\": \"mmol/L\", \"passport_observations/blood_glucose/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/blood_glucose/language|code\": \"en\", \"passport_observations/blood_glucose/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_glucose/encoding|code\": \"UTF-8\", \"passport_observations/blood_glucose/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/pulse_oximetry/spo|numerator\": 0.0, \"passport_observations/pulse_oximetry/spo|denominator\": 100.0, \"passport_observations/pulse_oximetry/spo|type\": 2, \"passport_observations/pulse_oximetry/spo\": 0.0, \"passport_observations/pulse_oximetry/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/pulse_oximetry/language|code\": \"en\", \"passport_observations/pulse_oximetry/language|terminology\": \"ISO_639-1\", \"passport_observations/pulse_oximetry/encoding|code\": \"UTF-8\", \"passport_observations/pulse_oximetry/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_temperature/temperature|magnitude\": 72.7, \"passport_observations/body_temperature/temperature|unit\": \"[degF]\", \"passport_observations/body_temperature/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/body_temperature/language|code\": \"en\", \"passport_observations/body_temperature/language|terminology\": \"ISO_639-1\", \"passport_observations/body_temperature/encoding|code\": \"UTF-8\", \"passport_observations/body_temperature/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/clinical_synopsis/notes\": \"Notes 9\", \"passport_observations/clinical_synopsis/language|code\": \"en\", \"passport_observations/clinical_synopsis/language|terminology\": \"ISO_639-1\", \"passport_observations/clinical_synopsis/encoding|code\": \"UTF-8\", \"passport_observations/clinical_synopsis/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/category|code\": \"433\", \"passport_observations/category|value\": \"event\", \"passport_observations/category|terminology\": \"openehr\", \"passport_observations/composer|name\": \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\" }, \"deleted\": false, \"lastVersion\": true, \"ehrId\": \"b4a4577f-7496-4053-ae60-45e22cfc9952\", \"lifecycleState\": \"COMPLETE\" }``` #### Other data formats The Better Ehrscape API offers several other serialisation formats. You can have a look at these by simply changing the `format` parameter on the `GET / composition` call, and the call Header `Accept` to switch between JSON and XML. ##### 'FLAT JSON' This uses the same path-shortening mechanism as structured JSON but flattens all of the tree structure to a set of name-value pairs. Some developers prefer this to the STRUCTURED format. format=FLAT Accept : `application/json' ##### 'RAW JSON' This is very similar to, but not identical to the openEHR Canonical JSON format, which essentially supercedes it. It very closely adheres tothe openEHR Reference model specification but is pretty voluminous format=RAW Accept : application/json' ##### 'RAW XML' This is 'canonical' openEHR XML which is also accepted by the openEHR REST API. It is the lingu-franca for all openEHR CDRs, even thosewhich do not support the REST CDR API, will normally accept and expose data in this XML format. format=RAW Accept : application/xml' ```","title":"Retrieving a Patient Observations Composition"},{"location":"passport/JPASS10-retrieving-observation-data/#retrieving-a-patient-observations-composition","text":"All data committed to an openEHR CDR is done so via a POST or PUT /composition call - as a JSON or XML 'blob'. This section will cover how to retrieve a previously stored Composition by running a GET / composition call. A number of data serialisation options, can be used on retrieval. In this case we will ask for the Better FLAT JSON format, as this is what we used when committing the composition, but you can commit and retrieve using different formats if you wish.","title":"Retrieving a Patient Observations Composition"},{"location":"passport/JPASS11-updating-observation-data/","text":"Updating Patient Observations data All new data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. Most compositions will only need to be updated if an error or omission needs to be corrected. All openEHR data is strictly audited and version controlled, so an Update operation requires a PUT /composition call . You will nearly always with to first retrieve the original version of the composition via a GET /composition call, update the JSON or XML object and then perform the PUT Better Ehrscape PUT /composition - Update composition Parameters compositionId : This is is the composition UID for the previous version of the composition i.e the version that you are about to overwrite. Don't worry about how we find this, just use the uid for the composition you just committed in the last section. format : This defines the format of JSON or XML that you are requesting. Use FLAT for this example. templateId : This is the identifier of the openEHR template, against which you need to validate the composition, in this case, ``. Request Postman cURL curl --location \\ --request PUT 'https://cdr.code4health.org/rest/v1/composition/7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1?format=FLAT&templateId=JMOHW%20-%20Passport%20observations.v0' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' \\ --data-raw ' { { \"passport_observations/_uid\" : \"7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"passport_observations/language|code\" : \"en\" , \"passport_observations/language|terminology\" : \"ISO_639-1\" , \"passport_observations/territory|code\" : \"JM\" , \"passport_observations/territory|terminology\" : \"ISO_3166-1\" , \"passport_observations/context/start_time\" : \"2020-10-18T16:16:21.449Z\" , \"passport_observations/context/setting|code\" : \"238\" , \"passport_observations/context/setting|value\" : \"other care\" , \"passport_observations/context/setting|terminology\" : \"openehr\" , \"passport_observations/blood_pressure/systolic|magnitude\" : 169 .0, \"passport_observations/blood_pressure/systolic|unit\" : \"mm[Hg]\" , \"passport_observations/blood_pressure/diastolic|magnitude\" : 692 .0, \"passport_observations/blood_pressure/diastolic|unit\" : \"mm[Hg]\" , \"passport_observations/blood_pressure/time\" : \"2020-10-18T16:16:21.452Z\" , \"passport_observations/blood_pressure/language|code\" : \"en\" , \"passport_observations/blood_pressure/language|terminology\" : \"ISO_639-1\" , \"passport_observations/blood_pressure/encoding|code\" : \"UTF-8\" , \"passport_observations/blood_pressure/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/height_length/height_length|magnitude\" : 609 .33, \"passport_observations/height_length/height_length|unit\" : \"cm\" , \"passport_observations/height_length/time\" : \"2020-10-18T16:16:21.453Z\" , \"passport_observations/height_length/language|code\" : \"en\" , \"passport_observations/height_length/language|terminology\" : \"ISO_639-1\" , \"passport_observations/height_length/encoding|code\" : \"UTF-8\" , \"passport_observations/height_length/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/body_weight/weight|magnitude\" : 380 .49, \"passport_observations/body_weight/weight|unit\" : \"kg\" , \"passport_observations/body_weight/time\" : \"2020-10-18T16:16:21.453Z\" , \"passport_observations/body_weight/language|code\" : \"en\" , \"passport_observations/body_weight/language|terminology\" : \"ISO_639-1\" , \"passport_observations/body_weight/encoding|code\" : \"UTF-8\" , \"passport_observations/body_weight/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/blood_glucose/test_name|code\" : \"14743-9\" , \"passport_observations/blood_glucose/test_name|value\" : \"Glucose [Moles/volume] in Capillary blood by Glucometer\" , \"passport_observations/blood_glucose/test_name|terminology\" : \"LOINC\" , \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|code\" : \"14743-9\" , \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|value\" : \"Glucose [Moles/volume] in Capillary blood by Glucometer\" , \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|terminology\" : \"LOINC\" , \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|magnitude\" : 52 .61, \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|unit\" : \"mmol/L\" , \"passport_observations/blood_glucose/time\" : \"2020-10-18T16:16:21.453Z\" , \"passport_observations/blood_glucose/language|code\" : \"en\" , \"passport_observations/blood_glucose/language|terminology\" : \"ISO_639-1\" , \"passport_observations/blood_glucose/encoding|code\" : \"UTF-8\" , \"passport_observations/blood_glucose/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/pulse_oximetry/spo|numerator\" : 0 .0, \"passport_observations/pulse_oximetry/spo|denominator\" : 100 .0, \"passport_observations/pulse_oximetry/spo|type\" : 2 , \"passport_observations/pulse_oximetry/spo\" : 0 .0, \"passport_observations/pulse_oximetry/time\" : \"2020-10-18T16:16:21.455Z\" , \"passport_observations/pulse_oximetry/language|code\" : \"en\" , \"passport_observations/pulse_oximetry/language|terminology\" : \"ISO_639-1\" , \"passport_observations/pulse_oximetry/encoding|code\" : \"UTF-8\" , \"passport_observations/pulse_oximetry/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/body_temperature/temperature|magnitude\" : 72 .7, \"passport_observations/body_temperature/temperature|unit\" : \"[degF]\" , \"passport_observations/body_temperature/time\" : \"2020-10-18T16:16:21.455Z\" , \"passport_observations/body_temperature/language|code\" : \"en\" , \"passport_observations/body_temperature/language|terminology\" : \"ISO_639-1\" , \"passport_observations/body_temperature/encoding|code\" : \"UTF-8\" , \"passport_observations/body_temperature/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/clinical_synopsis/notes\" : \"Notes 9\" , \"passport_observations/clinical_synopsis/language|code\" : \"en\" , \"passport_observations/clinical_synopsis/language|terminology\" : \"ISO_639-1\" , \"passport_observations/clinical_synopsis/encoding|code\" : \"UTF-8\" , \"passport_observations/clinical_synopsis/encoding|terminology\" : \"IANA_character-sets\" , \"passport_observations/category|code\" : \"433\" , \"passport_observations/category|value\" : \"event\" , \"passport_observations/category|terminology\" : \"openehr\" , \"passport_observations/composer|name\" : \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\" } NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'put' , url : 'https://rest.ehrscape.com/rest/v1/rest/v1/composition/7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1?format=FLAT&templateId=JMOHW%20-%20Passport%20observations.v0' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Authorization: ' , } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests url = \"https://rest.ehrscape.com/rest/v1/composition/7b20dc2b-6494-467d-8986-469367f7c75b::4cce5a07-be4d-4318-a94f-3b8401853a20::1?format=FLAT&templateId=JMOHW%20-%20Passport %20o bservations.v0\" payload = {} headers = { 'Content-Type' : 'application/json' , 'Authorization: ' , } ' response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response { \"meta\" : { \"href\" : \"https://rest.ehrscape.com/rest/v1/composition/b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::2\" }, \"action\" : \"UPDATE\" , \"compositionUid\" : \"b0d7f6cb-a429-49b2-b5f3-9637b409eebd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::2\" } If the update is successful a 200 code will be returned.","title":"Updating Patient Observations data"},{"location":"passport/JPASS11-updating-observation-data/#updating-patient-observations-data","text":"All new data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. Most compositions will only need to be updated if an error or omission needs to be corrected. All openEHR data is strictly audited and version controlled, so an Update operation requires a PUT /composition call . You will nearly always with to first retrieve the original version of the composition via a GET /composition call, update the JSON or XML object and then perform the PUT","title":"Updating Patient Observations data"},{"location":"passport/JPASS12-composition-constraints/","text":"Understanding composition Constraints and validation As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference Model schema. If the data is valid, it will be stored in the CDR and is allocated a unique compositionID , which is returned by the POST /composition call on a successful call. One of the key challenges in working with openEHR, is in understanding the complexities of the various datatypes and the other validation rules that apply for any particular template. The constraint and validation rules are applied in by The Reference model Archetype-level constraints Template-level constraints How to figure out which constraints apply? As an example, I know that a particular coded entry list (perhaps drop-down) allows only a fixed selection of possible answers, which are probably coded ( a good example being a PROMS score). Where can I find how these are defined? The ultimate source of truth is the .opt 'Operational template' which is uploaded to the CDR. It is essentially an aggregation of all the archetype constraints, and any local template constraints, which are than applied ot the underlying RM to give the full validation target. The .opt is a faithful representation of the underlying in-memory objects but is a pretty difficult beast to parse and understand. Fortunately Better provide a 'web template' utility which generates a JSON version of the validation statement but in a much more understandable format -both for human consumption and parsing. The web template facility is available both from the Ehrscape API, and as an export option from the openEHR Archetype Designer. We understand that ehrBase are developing a similar export facility and we expect this to become part of the openEHR standard in due course. Better Ehrscape: `GET /template - Retrieve a web template' Parameters templateId : This is the identifier of the openEHR template, against which you need to validate the composition, in this case DHI - Urology_PROMs-v0 format : This defines the format of JSON or XML that you are sending. Use STRUCTURED for this example. Request Postman cURL curl --location \\ --request GET 'https://rest.ehrscape.com/rest/v1/template/JMOHW - Passport observations.v0' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' \\ NodeJS/Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://rest.ehrscape.com/rest/v1/template/JMOHW - Passport observations.v0' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests `` ` python import requests url = \"https://rest.ehrscape.com/rest/v1/template/JMOHW - Passport observations.v0\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' , } response = requests . request ( \"GET\" , url , headers = headers ) print ( response . text . encode ( 'utf8' )) ``` Response { \"meta\" : { \"href\" : \"https://cdr.code4health.org/rest/v1/template/JMOHW%20-%20Passport%20observations.v0\" }, \"webTemplate\" : { \"templateId\" : \"JMOHW - Passport observations.v0\" , \"version\" : \"2.3\" , \"defaultLanguage\" : \"en\" , \"languages\" : [ \"en\" ], \"tree\" : { \"id\" : \"passport_observations\" , \"name\" : \"Passport observations\" , \"localizedName\" : \"Passport observations\" , \"rmType\" : \"COMPOSITION\" , \"nodeId\" : \"openEHR-EHR-COMPOSITION.encounter.v1\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Passport observations\" }, \"localizedDescriptions\" : { \"en\" : \"Interaction, contact or care event between a subject of care and healthcare provider(s).\" }, \"aqlPath\" : \"\" , \"children\" : [ { \"id\" : \"context\" , \"rmType\" : \"EVENT_CONTEXT\" , \"nodeId\" : \"\" , \"min\" : 1 , \"max\" : 1 , \"aqlPath\" : \"/context\" , \"children\" : [ { \"id\" : \"start_time\" , \"name\" : \"Start_time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/context/start_time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"setting\" , \"name\" : \"Setting\" , \"rmType\" : \"DV_CODED_TEXT\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/context/setting\" , \"inputs\" : [ { \"suffix\" : \"code\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"value\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"blood_pressure\" , \"name\" : \"Blood pressure\" , \"localizedName\" : \"Blood pressure\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.blood_pressure.v2\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Blood pressure\" }, \"localizedDescriptions\" : { \"en\" : \"The local measurement of arterial blood pressure which is a surrogate for arterial pressure in the systemic circulation.\" }, \"annotations\" : { \"comment\" : \"Most commonly, use of the term 'blood pressure' refers to measurement of brachial artery pressure in the upper arm.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]\" , \"children\" : [ { \"id\" : \"systolic\" , \"name\" : \"Systolic\" , \"localizedName\" : \"Systolic\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0004\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Systolic\" }, \"localizedDescriptions\" : { \"en\" : \"Peak systemic arterial blood pressure - measured in systolic or contraction phase of the heart cycle.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/data[at0001]/events[at0006]/data[at0003]/items[at0004]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<\" , \"max\" : 1000.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 0 , \"maxOp\" : \"<=\" , \"max\" : 0 } } }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"mm[Hg]\" , \"label\" : \"mm[Hg]\" , \"localizedLabels\" : { \"en\" : \"mmHg\" }, \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<\" , \"max\" : 1000.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 0 , \"maxOp\" : \"<=\" , \"max\" : 0 } } } ] } ], \"termBindings\" : { \"SNOMED-CT\" : { \"value\" : \"[SNOMED-CT(2003)::271649006]\" , \"terminologyId\" : \"SNOMED-CT\" } } }, { \"id\" : \"diastolic\" , \"name\" : \"Diastolic\" , \"localizedName\" : \"Diastolic\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0005\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Diastolic\" }, \"localizedDescriptions\" : { \"en\" : \"Minimum systemic arterial blood pressure - measured in the diastolic or relaxation phase of the heart cycle.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/data[at0001]/events[at0006]/data[at0003]/items[at0005]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<\" , \"max\" : 1000.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 0 , \"maxOp\" : \"<=\" , \"max\" : 0 } } }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"mm[Hg]\" , \"label\" : \"mm[Hg]\" , \"localizedLabels\" : { \"en\" : \"mmHg\" }, \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<\" , \"max\" : 1000.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 0 , \"maxOp\" : \"<=\" , \"max\" : 0 } } } ] } ], \"termBindings\" : { \"SNOMED-CT\" : { \"value\" : \"[SNOMED-CT(2003)::271650006]\" , \"terminologyId\" : \"SNOMED-CT\" } } }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/data[at0001]/events[at0006]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.blood_pressure.v2]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ], \"termBindings\" : { \"SNOMED-CT\" : { \"value\" : \"[SNOMED-CT(2003)::364090009]\" , \"terminologyId\" : \"SNOMED-CT\" } } }, { \"id\" : \"height_length\" , \"name\" : \"Height/Length\" , \"localizedName\" : \"Height/Length\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.height.v2\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Height/Length\" }, \"localizedDescriptions\" : { \"en\" : \"Height, or body length, is measured from crown of head to sole of foot.\" }, \"annotations\" : { \"comment\" : \"Height is measured with the individual in a standing position and body length in a recumbent position.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]\" , \"children\" : [ { \"id\" : \"height_length\" , \"name\" : \"Height/Length\" , \"localizedName\" : \"Height/Length\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0004\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Height/Length\" }, \"localizedDescriptions\" : { \"en\" : \"The length of the body from crown of head to sole of foot.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]/data[at0001]/events[at0002]/data[at0003]/items[at0004]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<=\" , \"max\" : 1000.0 } } }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"cm\" , \"label\" : \"cm\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<=\" , \"max\" : 1000.0 } } } ] } ] }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]/data[at0001]/events[at0002]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.height.v2]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"body_weight\" , \"name\" : \"Body weight\" , \"localizedName\" : \"Body weight\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.body_weight.v2\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Body weight\" }, \"localizedDescriptions\" : { \"en\" : \"Measurement of the body weight of an individual.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]\" , \"children\" : [ { \"id\" : \"weight\" , \"name\" : \"Weight\" , \"localizedName\" : \"Weight\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0004\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Weight\" }, \"localizedDescriptions\" : { \"en\" : \"The weight of the individual.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]/data[at0002]/events[at0003]/data[at0001]/items[at0004]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<=\" , \"max\" : 1000.0 } } }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"kg\" , \"label\" : \"kg\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<=\" , \"max\" : 1000.0 } } } ] } ] }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]/data[at0002]/events[at0003]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_weight.v2]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"blood_glucose\" , \"name\" : \"Blood glucose\" , \"localizedName\" : \"Blood glucose\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.laboratory_test_result.v1\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Blood glucose\" }, \"localizedDescriptions\" : { \"en\" : \"The result, including findings and the laboratory's interpretation, of an investigation performed on specimens collected from an individual or related to that individual.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']\" , \"children\" : [ { \"id\" : \"test_name\" , \"name\" : \"Test name\" , \"localizedName\" : \"Test name\" , \"rmType\" : \"DV_CODED_TEXT\" , \"nodeId\" : \"at0005\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Test name\" }, \"localizedDescriptions\" : { \"en\" : \"Name of the laboratory investigation performed on the specimen(s).\" }, \"annotations\" : { \"comment\" : \"A test result may be for a single analyte, or a group of items, including panel tests. It is strongly recommended that 'Test name' be coded with a terminology, for example LOINC or SNOMED CT. For example: 'Glucose', 'Urea and Electrolytes', 'Swab', 'Cortisol (am)', 'Potassium in perspiration' or 'Melanoma histopathology'. The name may sometimes include specimen type and patient state, for example 'Fasting blood glucose' or include other information, as 'Potassium (PNA blood gas)'.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/data[at0001]/events[at0002]/data[at0003]/items[at0005]/value\" , \"inputs\" : [ { \"suffix\" : \"code\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"14743-9\" , \"label\" : \"Glucose [Moles/volume] in Capillary blood by Glucometer\" , \"localizedLabels\" : { \"en\" : \"\" } } ], \"defaultValue\" : \"14743-9\" , \"terminology\" : \"LOINC\" } ] }, { \"id\" : \"laboratory_analyte_result\" , \"name\" : \"Laboratory analyte result\" , \"localizedName\" : \"Laboratory analyte result\" , \"rmType\" : \"CLUSTER\" , \"nodeId\" : \"openEHR-EHR-CLUSTER.laboratory_test_analyte.v1\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Laboratory analyte result\" }, \"localizedDescriptions\" : { \"en\" : \"The result of a laboratory test for a single analyte value.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/data[at0001]/events[at0002]/data[at0003]/items[openEHR-EHR-CLUSTER.laboratory_test_analyte.v1]\" , \"children\" : [ { \"id\" : \"analyte_name\" , \"name\" : \"Analyte name\" , \"localizedName\" : \"Analyte name\" , \"rmType\" : \"DV_CODED_TEXT\" , \"nodeId\" : \"at0024\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Analyte name\" }, \"localizedDescriptions\" : { \"en\" : \"The name of the analyte result.\" }, \"annotations\" : { \"comment\" : \"The value for this element is normally supplied in a specialisation, in a template or at run-time to reflect the actual analyte. For example: 'Serum sodium', 'Haemoglobin'. Coding with an external terminology is strongly recommended, such as LOINC, NPU, SNOMED CT, or local lab terminologies.\" , \"hl7v2_mapping\" : \"OBX.3\" , \"fhir_mapping\" : \"Observation.code\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/data[at0001]/events[at0002]/data[at0003]/items[openEHR-EHR-CLUSTER.laboratory_test_analyte.v1]/items[at0024]/value\" , \"inputs\" : [ { \"suffix\" : \"code\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"14743-9\" , \"label\" : \"Glucose [Moles/volume] in Capillary blood by Glucometer\" , \"localizedLabels\" : { \"en\" : \"\" } } ], \"defaultValue\" : \"14743-9\" , \"terminology\" : \"LOINC\" } ] }, { \"id\" : \"analyte_result\" , \"name\" : \"Analyte result\" , \"localizedName\" : \"Analyte result\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0001\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Analyte result\" }, \"localizedDescriptions\" : { \"en\" : \"The value of the analyte result.\" }, \"annotations\" : { \"comment\" : \"For example '7.3 mmol/l', 'Raised'. The 'Any' data type will need to be constrained to an appropriate data type in a specialisation, a template or at run-time to reflect the actual analyte result. The Quantity data type has reference model attributes that include flags for normal/abnormal, reference ranges and approximations - see https://specifications.openehr.org/releases/RM/latest/data_types.html#_dv_quantity_class for more details.\" , \"hl7v2_mapping\" : \"OBX.2, OBX.5, OBX.6, OBX.7, OBX.8\" , \"fhir_mapping\" : \"Observation.value[x]\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/data[at0001]/events[at0002]/data[at0003]/items[openEHR-EHR-CLUSTER.laboratory_test_analyte.v1]/items[at0001]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"mmol/L\" , \"label\" : \"mmol/L\" } ] } ] } ] }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/data[at0001]/events[at0002]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.laboratory_test_result.v1,'Blood glucose']/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"pulse_oximetry\" , \"name\" : \"Pulse oximetry\" , \"localizedName\" : \"Pulse oximetry\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.pulse_oximetry.v1\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Pulse oximetry\" }, \"localizedDescriptions\" : { \"en\" : \"Blood oxygen and related measurements, measured by pulse oximetry or pulse CO-oximetry.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]\" , \"children\" : [ { \"id\" : \"spo\" , \"name\" : \"SpO\u2082\" , \"localizedName\" : \"SpO\u2082\" , \"rmType\" : \"DV_PROPORTION\" , \"nodeId\" : \"at0006\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"SpO\u2082\" }, \"localizedDescriptions\" : { \"en\" : \"The saturation of oxygen in the peripheral blood, measured via pulse oximetry.\" }, \"annotations\" : { \"comment\" : \"SpO\u2082 is defined as the percentage of oxyhaemoglobin (HbO\u2082) to the total concentration of haemoglobin (HbO\u2082 + deoxyhaemoglobin) in peripheral blood.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]/data[at0001]/events[at0002]/data[at0003]/items[at0006]/value\" , \"proportionTypes\" : [ \"percent\" ], \"inputs\" : [ { \"suffix\" : \"numerator\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 0.0 , \"maxOp\" : \"<=\" , \"max\" : 100.0 } }, \"defaultValue\" : 0.0 }, { \"suffix\" : \"denominator\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 100.0 , \"maxOp\" : \"<=\" , \"max\" : 100.0 } } } ], \"termBindings\" : { \"SNOMED-CT\" : { \"value\" : \"[SNOMED-CT::431314004]\" , \"terminologyId\" : \"SNOMED-CT\" }, \"LOINC\" : { \"value\" : \"[LOINC::59408-5]\" , \"terminologyId\" : \"LOINC\" } } }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]/data[at0001]/events[at0002]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.pulse_oximetry.v1]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"body_temperature\" , \"name\" : \"Body temperature\" , \"localizedName\" : \"Body temperature\" , \"rmType\" : \"OBSERVATION\" , \"nodeId\" : \"openEHR-EHR-OBSERVATION.body_temperature.v2\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Body temperature\" }, \"localizedDescriptions\" : { \"en\" : \"A measurement of the body temperature, which is a surrogate for the core body temperature of the individual.\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]\" , \"children\" : [ { \"id\" : \"temperature\" , \"name\" : \"Temperature\" , \"localizedName\" : \"Temperature\" , \"rmType\" : \"DV_QUANTITY\" , \"nodeId\" : \"at0004\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Temperature\" }, \"localizedDescriptions\" : { \"en\" : \"The measured body temperature (as a surrogate for the core of the body).\" }, \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]/data[at0002]/events[at0003]/data[at0001]/items[at0004]/value\" , \"inputs\" : [ { \"suffix\" : \"magnitude\" , \"type\" : \"DECIMAL\" , \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 30.0 , \"maxOp\" : \"<\" , \"max\" : 200.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 1 , \"maxOp\" : \"<=\" , \"max\" : 1 } } }, { \"suffix\" : \"unit\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"[degF]\" , \"label\" : \"[degF]\" , \"localizedLabels\" : { \"en\" : \"\u00b0F\" }, \"validation\" : { \"range\" : { \"minOp\" : \">=\" , \"min\" : 30.0 , \"maxOp\" : \"<\" , \"max\" : 200.0 }, \"precision\" : { \"minOp\" : \">=\" , \"min\" : 1 , \"maxOp\" : \"<=\" , \"max\" : 1 } } } ] } ], \"termBindings\" : { \"LNC205\" : { \"value\" : \"[LNC205::8310-5]\" , \"terminologyId\" : \"LNC205\" }, \"SNOMED-CT\" : { \"value\" : \"[SNOMED-CT::386725007]\" , \"terminologyId\" : \"SNOMED-CT\" } } }, { \"id\" : \"time\" , \"name\" : \"Time\" , \"rmType\" : \"DV_DATE_TIME\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]/data[at0002]/events[at0003]/time\" , \"inputs\" : [ { \"type\" : \"DATETIME\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-OBSERVATION.body_temperature.v2]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"clinical_synopsis\" , \"name\" : \"Clinical synopsis\" , \"localizedName\" : \"Clinical synopsis\" , \"rmType\" : \"EVALUATION\" , \"nodeId\" : \"openEHR-EHR-EVALUATION.clinical_synopsis.v1\" , \"min\" : 0 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Clinical synopsis\" }, \"localizedDescriptions\" : { \"en\" : \"Narrative summary or overview about a patient, specifically from the perspective of a healthcare provider, and with or without associated interpretations.\" }, \"aqlPath\" : \"/content[openEHR-EHR-EVALUATION.clinical_synopsis.v1]\" , \"children\" : [ { \"id\" : \"notes\" , \"name\" : \"Notes\" , \"localizedName\" : \"Notes\" , \"rmType\" : \"DV_TEXT\" , \"nodeId\" : \"at0002\" , \"min\" : 1 , \"max\" : 1 , \"localizedNames\" : { \"en\" : \"Notes\" }, \"localizedDescriptions\" : { \"en\" : \"The summary, assessment, conclusions or evaluation of the clinical findings.\" }, \"aqlPath\" : \"/content[openEHR-EHR-EVALUATION.clinical_synopsis.v1]/data[at0001]/items[at0002,'Notes']/value\" , \"inputs\" : [ { \"type\" : \"TEXT\" } ] }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-EVALUATION.clinical_synopsis.v1]/language\" , \"inContext\" : true }, { \"id\" : \"encoding\" , \"name\" : \"Encoding\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-EVALUATION.clinical_synopsis.v1]/encoding\" , \"inContext\" : true }, { \"id\" : \"subject\" , \"name\" : \"Subject\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/content[openEHR-EHR-EVALUATION.clinical_synopsis.v1]/subject\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] }, { \"id\" : \"category\" , \"rmType\" : \"DV_CODED_TEXT\" , \"nodeId\" : \"\" , \"min\" : 1 , \"max\" : 1 , \"aqlPath\" : \"/category\" , \"inputs\" : [ { \"suffix\" : \"code\" , \"type\" : \"CODED_TEXT\" , \"list\" : [ { \"value\" : \"433\" , \"label\" : \"event\" , \"localizedLabels\" : { \"en\" : \"event\" } } ], \"terminology\" : \"openehr\" } ], \"inContext\" : true }, { \"id\" : \"language\" , \"name\" : \"Language\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/language\" , \"inContext\" : true }, { \"id\" : \"territory\" , \"name\" : \"Territory\" , \"rmType\" : \"CODE_PHRASE\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/territory\" , \"inContext\" : true }, { \"id\" : \"composer\" , \"name\" : \"Composer\" , \"rmType\" : \"PARTY_PROXY\" , \"min\" : 0 , \"max\" : 1 , \"aqlPath\" : \"/composer\" , \"inputs\" : [ { \"suffix\" : \"id\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_scheme\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"id_namespace\" , \"type\" : \"TEXT\" }, { \"suffix\" : \"name\" , \"type\" : \"TEXT\" } ], \"inContext\" : true } ] } } }","title":"Understanding composition Constraints and validation"},{"location":"passport/JPASS12-composition-constraints/#understanding-composition-constraints-and-validation","text":"As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference Model schema. If the data is valid, it will be stored in the CDR and is allocated a unique compositionID , which is returned by the POST /composition call on a successful call. One of the key challenges in working with openEHR, is in understanding the complexities of the various datatypes and the other validation rules that apply for any particular template. The constraint and validation rules are applied in by The Reference model Archetype-level constraints Template-level constraints","title":"Understanding composition Constraints and validation"},{"location":"passport/JPASS13-openehr-datatypes/","text":"Key openEHR datatypes The openEHR Reference model defines a relatively small set of information model constructs which openEHR back-ends must support. This includes a number of generic classes and datatypes. The Reference model contains virtually no clinical content e.g concepts for Medication, or Diagnosis. These are defined and managed separately as archetypes . openEHR has a very rich set of allowable datatypes. A full definition is beyond the scope of this document but developers new to this field may find the following notes helpful. You can refer to the openEHR Specification and UML for full details. The formal Class names for all datatypes in openEHR start with DV_ Datatype: text ( DV_TEXT ) Allows the recording of simple, unformatted text. Newlines and carriage returns are allowed. openEHR does not normally constrain the length of string. The example shows how a multiple occurrence Element is handled. RM Specs The rm.data_types.text package contains classes for representing all textual values in the health record, including plain text, coded terms, and narrative text. CANONICAL JSON { { \"items\" : [ { \"_type\" : \"ELEMENT\" , \"name\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"What matters to me\" }, \"archetype_node_id\" : \"at0004\" , \"value\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"Parents\" } }, { \"_type\" : \"ELEMENT\" , \"name\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"What matters to me #2\" }, \"archetype_node_id\" : \"at0004\" , \"value\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"Mood\" } }, { \"_type\" : \"ELEMENT\" , \"name\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"What matters to me #3\" }, \"archetype_node_id\" : \"at0004\" , \"value\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"Isolation\" } } ] } STRUCTURED JSON \"what_matters_to_me\" : [ \"Parents\" , \"Mood\" , \"Isolation\" ] } FLAT JSON ```json { \"what_matters_to_me:0\" : \"Parents\" , \"what_matters_to_me:1\" : \"Mood\" , \"what_matters_to_me:2\" : \"Isolation\" } Hint DV_TEXT can always be sub-classed to DV_CODED_TEXT , so when you see a text constraint in an archetype , this can normally always be converted to a codedText in a template or at run-time. As an example, the primary element in the Adverse reaction risk archetype is a DV_TEXT but in most circumstances a DV_CODED_TEXT will actually be used. Datatype: codedText ( DV_CODED_TEXT ) Is a commonly used datatype in openEHR systems and is a sub-class of text . i.e wherever text is specified codedText can be used instead. Codes may be 'external' e.g. SNOMED CT, LOINC, ICD-10 or 'local', where they are defined within archetypes, have the form atxxxxx and are commonly referred to as 'atCodes' . A codedText element always includes the terminologyID, the code itself and the text of the coded concept (Rubric). In the patient data this is a carried in the defining_code attribute of the datatype. RM Specs The rm.data_types.text package contains classes for representing all textual values in the health record, including plain text, coded terms, and narrative text. CANONICAL JSON { \"_type\" : \"ELEMENT\" , \"name\" : { \"_type\" : \"DV_TEXT\" , \"value\" : \"Status\" }, \"archetype_node_id\" : \"at0004\" , \"value\" : { \"_type\" : \"DV_CODED_TEXT\" , \"value\" : \"Unknown\" , \"defining_code\" : { \"_type\" : \"CODE_PHRASE\" , \"terminology_id\" : { \"_type\" : \"TERMINOLOGY_ID\" , \"value\" : \"local\" }, \"code_string\" : \"at0007\" } } } STRUCTURED JSON \"legal_welfare_proxy_in_place\" : [ { \"status\" : [ { \"|code\" : \"at0007\" , \"|value\" : \"Unknown\" , \"|terminology\" : \"local\" } ], } ] FLAT JSON \"legal_welfare_proxy_in_place/status|value\" : \"Unknown\" , \"legal_welfare_proxy_in_place/status|code\" : \"at0007\" , \"legal_welfare_proxy_in_place/status|terminology\" : \"local\" Using local 'atCodes' e.g local::at0007| normal| When a codedText item is added to a FLAT or STRUCTURED JSON format document, you must give the code, value and terminology, unless this is a local 'atCode', in which case only the code needs to be provided, as the terminologyId and text value will be supplied as defaults, based on the known values in the template. Only the code needs to be specified - the value and terminology are not required since they are pre-defined in the openEHR template.. FLAT JSON asthma_diary_entry/examination_findings: 0 /pulmonary_function_testing: 0 /result_details/pulmonary_flow_rate_result/test_result_name|code': 'at 0071 ' Using external terminology e.g. SNOMED-CT::23924001| chest tightness | If an external terminology is used, the code, terminology and value must be specified FLAT JSON ```json 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|code': '23924001', 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|value': 'chest tightness', 'asthma_diary_entry/history:0/story_history/symptom:0/symptom_name|terminology': 'SNOMED-CT', ``` Handling multiple codes - Mappings Both DV_TEXT and DV_CODED_TEXT allow for other codes to be recorded in the patient record alongside the text value or defining code. THis is done via the mappings attribute in the DV_TEXT/DV_CODED_TEXT datatype. RM Specs CANONICAL JSON STRUCTURED JSON FLAT JSON Datatype: ordinal DV_ORDINAL and scale DV_SCALE Combines codedText with a score, expressed as an integer (DV_ORDINAL) or a real number (DV_SCALE). DV_SCALE is just being introduced in the latest version of the Reference Model to support the small number of scales and scores that need real numbers. We expect DV_SCALE to be used in preference to DV_ORDINAL for new archetypes. 0 : Green ` local :: at0022 :: Green ` 1 : Amber ` local :: at0023 :: Amber ` 2 : Red ` local :: at0024 :: Red ` 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|code' : 'at0024' , 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|ordinal' : 2 , 'community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|value' : 'Red' , Datatype: count count is a simple integer. 'community_dental_final_assessment_letter/investigations_and_results:0/imaging_examination_result:0/result_group/decayed_teeth/decayed_teeth': 4, Datatype: datetime Records a date or date and time using the ISO8061 format . 'ctx/time': '2014-09-23T00:11:02.518+02:00' Datatype: quantity Records a physical quantity along with the appropriate SI units, which should normally be compliant with UCUM . \"asthma_diary_entry/examination_findings:0/pulmonary_function_testing:0/result_details/pulmonary_flow_rate_result/actual_result|magnitude\": 550, \"asthma_diary_entry/examination_findings:0/pulmonary_function_testing:0/result_details/pulmonary_flow_rate_result/actual_result|unit\": \"l/min\", Key openEHR Reference model attributes A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model. committer This is the name of the person physically committing the document ie. the person logged on to the account. If omitted from API calls, Ehrscape will use the domain login name. composition/composer This is the clinical author of the document i.e the person with clinical responsibility. Ehrscape FLAT and STRCTURTED formats handle this as composer_name . composition/context/start_time This is the time that the clinical interaction with the patient began. Ehrscape FLAT and STRUCTURED formats handle this as ctx/time. composition/context/health_care_facility This is the healthcare facility / oragnisation under who\u2019s remit the encounter took place. observation/time This is the time that a patient\u2019s signs and symptoms were observed or a test was run. It is set automatically by the value of the ctx/time attribute. If you need to set the time of a specific observation you can use The Ehrscape FLAT and STRUCTURED formats hide much of the complexity of these attributes, providing sensible defaults. In particular the ctx header common to both JSON STRUCTURED and FLAT formats, considerably simplifies the composition header \u2026 'ctx/composer_name': 'Rebecca Wassall', 'ctx/health_care_facility|id': '999999-345', 'ctx/health_care_facility|name': 'Northumbria Community NHS', 'ctx/id_namespace': 'NHS-UK', 'ctx/id_scheme': '2.16.840.1.113883.2.1.4.3', 'ctx/language': 'en', 'ctx/territory': 'GB', 'ctx/time': '2014-09-23T00:11:02.518+02:00', Handling specific openEHR datatypes text Text handling is normally straightforward. FLAT + STRUCTURED \"synopsis\": [ \"Significant dental issues.\" ] codedText For an external terminology, the terminologyId, code and text value must be supplied but in JSON FLAT and STRUCTURED formats only the local 'atcode' needs to be supplied. STRUCTURED JSON format Internal (local) code: \"dental_swelling\": [ { \"|code\": \"at0006\", } ] External terminology: \"symptom_name\": [ { \"|code\": \"102616008\", \"|terminology\": \"SNOMED-CT\", \"|value\": \"Painful mouth\" } ] FLAT JSON format Internal (local) code: \"community_dental_final_assessment_letter/examination_findings:0/physical_examination_findings:0/oral_examination/dental_swelling|code\" : \"at0006\" External terminology: \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|value\" : \"Painful mouth\" , \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|code\" : \"102616008\" , \"community_dental_final_assessment_letter/history:0/story_history:0/symptom:0/symptom_name|terminology\" : \"SNOMED-CT\" ordinal For JSON FLAT and STRUCTURED formats only the local 'atcode' needs to be supplied although the ordinal and text value are also accepted FLAT JSON format \"community_dental_final_assessment_letter/assessment_scales/dental_rag_score:0/caries_tooth_decay/caries_risk|code\": \"at0024\" STRUCTURED format \"caries_risk\" : [ { \"|code\" : \"at0024\" , } ] or \"caries_risk\" : [ { \"|code\" : \"at0024\" , \"|ordinal\" : 2 , \"|value\" : \"Red\" } ] date Dates need to be persisted in the ISO8061format and should be displayed in CUI format e.g. 12-Nov-1958 Tricky issues Converting UI checkboxes to/from codedText In a number of places, the UI may best be represented as a set of checkboxes, while the underlying data is modelled as codedText. e.g. Symptoms While it may seem more easier and more logical to use a boolean datatype, this is a common pattern in openEHR datasets which are designed to be interoperable and extensible. Experience has shown that expansion of the target valueset and alignment to external terminologies is easier if an enumerated list of codedText is used rather than boolean. In the case of 'Symptom' the rule is \u2026 If the checkbox is ticked, populate the Symptom name with the SNOMED-CT term If the checkbox is unticked, omit the Symptom name element completely. Conversely when loading a persisted dataset, the checkbox should only be checked if the Symptom name element is present and contains SNOMED-CT term 102616008. Multiple occurrence data Some aspects of the form e.g Symptoms are handled as multiple occurrences of the same data point in the underlying dataset.","title":"openEHR Datatypes"},{"location":"passport/JPASS13-openehr-datatypes/#key-openehr-datatypes","text":"The openEHR Reference model defines a relatively small set of information model constructs which openEHR back-ends must support. This includes a number of generic classes and datatypes. The Reference model contains virtually no clinical content e.g concepts for Medication, or Diagnosis. These are defined and managed separately as archetypes . openEHR has a very rich set of allowable datatypes. A full definition is beyond the scope of this document but developers new to this field may find the following notes helpful. You can refer to the openEHR Specification and UML for full details. The formal Class names for all datatypes in openEHR start with DV_","title":"Key openEHR datatypes"},{"location":"passport/JPASS13-openehr-datatypes/#key-openehr-reference-model-attributes","text":"A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model.","title":"Key openEHR Reference model attributes"},{"location":"passport/JPASS13-openehr-datatypes/#handling-specific-openehr-datatypes","text":"","title":"Handling specific openEHR datatypes"},{"location":"passport/JPASS13-openehr-datatypes/#tricky-issues","text":"","title":"Tricky issues"},{"location":"passport/JPASS14-openehr-rm-attributes/","text":"Key openEHR RM attributes The openEHR Reference model defines a relatively small set of information model constructs which openEHR back-ends must support. This includes a number of generic classes and datatypes. The Reference model contains virtually no clinical content e.g concepts for Medication, or Diagnosis. These are defined and managed separately as archetypes . A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model. committer This is the name of the person physically committing the document ie. the person logged on to the account. If omitted from API calls, Ehrscape will use the domain login name. composition/composer This is the clinical author of the document i.e the person with clinical responsibility. Ehrscape FLAT and STRCTURTED formats handle this as composer_name . composition/context/start_time This is the time that the clinical interaction with the patient began. Ehrscape FLAT and STRUCTURED formats handle this as ctx/time. composition/context/health_care_facility This is the healthcare facility / oragnisation under who\u2019s remit the encounter took place. observation/time This is the time that a patient\u2019s signs and symptoms were observed or a test was run. It is set automatically by the value of the ctx/time attribute. If you need to set the time of a specific observation you can use The Ehrscape FLAT and STRUCTURED formats hide much of the complexity of these attributes, providing sensible defaults. In particular the ctx header common to both JSON STRUCTURED and FLAT formats, considerably simplifies the composition header \u2026 'ctx/composer_name': 'Rebecca Wassall', 'ctx/health_care_facility|id': '999999-345', 'ctx/health_care_facility|name': 'Northumbria Community NHS', 'ctx/id_namespace': 'NHS-UK', 'ctx/id_scheme': '2.16.840.1.113883.2.1.4.3', 'ctx/language': 'en', 'ctx/territory': 'GB', 'ctx/time': '2014-09-23T00:11:02.518+02:00',","title":"Key openEHR RM attributes"},{"location":"passport/JPASS14-openehr-rm-attributes/#key-openehr-rm-attributes","text":"The openEHR Reference model defines a relatively small set of information model constructs which openEHR back-ends must support. This includes a number of generic classes and datatypes. The Reference model contains virtually no clinical content e.g concepts for Medication, or Diagnosis. These are defined and managed separately as archetypes . A number of key data points need to be populated in an openEHR composition, which may not be apparent from the archetypes or templates. Developers can largely use the example instance documents and APIs for guidance but these notes may give useful background in addition to viewing the UML view of the openEHR reference model.","title":"Key openEHR RM attributes"},{"location":"passport/JPASS2-retrieving-an-ehrid/","text":"Retrieving the patient's ehrId When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. a Jamaican NIN number or hospital MRI) is submitted by a POST /ehr | create EHR from SubjectId call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Most openCDR API calls require an 'ehrId' to identify the correct patient, so normally the first activity required if interacting with a patient record is to retrieve their ehrId , and then often to cache that identifier so it can be used for subsequent calls, until a new patient is being accessed. GET /ehr - retrieve ehr from subjectId/subjectNamespace Parameters subjectId This is the external identifier by which the patient is known within the CDR. It is normally a real-word identifier like a Jamaica NIN number or Hospital 'MRI' number, and will have been supplied to the CDR when the patients' EHR object was created in the datastore. Example value : 9999999000 subjectNamespace This is just a unique string used to identify the numbering scheme used for the subjectId . It will commonly be some sort of URI such as uk_nhs_nhs_number and will have been agreed at national level. Example value : uk_nhs_nhs_number Postman cURL curl --location \\ --request GET '/ehr/?subjectId=https://rest.ehrscape.com/rest/openehr/v19999999000&subjectNamespace=uk.nhs.nhs_number' \\ --header 'Content-Type: application/json' \\ --header 'Accept: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' --header 'PREFER: return=minimal' \\ NodeJs - Axios var axios = require ( 'axios' ); var config = { method : 'get' , url : 'https://rest.ehrscape.com/rest/openehr/v1/ehr?subject_id=9999999000&subject_namespace=uk.nhs.nhs_number' , headers : { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' , 'PREFER' : 'return=minimal' , 'Authorization' : Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ == ' } }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://rest.ehrscape.com/rest/openehr/v1/ehr?subject_id=9999999000&subject_namespace=uk.nhs.nhs_number\" payload = {} headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' , 'PREFER' : 'return=minimal' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"GET\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response An openCDR will give a 200 response code and this structure. The ehrId that you need to capture is ehr_id.value item in the response. Hint You may want to consider caching this for the session, so that it can be used for a number of subsequent calls. { \"_type\" : \"EHR\" , \"system_id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"4cce5a07-be4d-4318-a94f-3b8401853a20\" }, \"ehr_id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"5dd03bc9-4419-4981-8798-ff4dda8ee9de\" }, \"time_created\" : { \"_type\" : \"DV_DATE_TIME\" , \"value\" : \"2020-07-21T09:00:24.977Z\" }, \"ehr_status\" : { \"_type\" : \"EHR_STATUS\" , \"uid\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"09bcd903-1565-44db-9087-2ff5e5bc7194::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" }, \"subject\" : { \"_type\" : \"PARTY_SELF\" , \"external_ref\" : { \"_type\" : \"PARTY_REF\" , \"id\" : { \"_type\" : \"HIER_OBJECT_ID\" , \"value\" : \"9999999000\" }, \"namespace\" : \"uk.nhs.nhs_number\" } }, \"is_queryable\" : true , \"is_modifiable\" : true } }","title":"Retrieving the patient's ehrId"},{"location":"passport/JPASS2-retrieving-an-ehrid/#retrieving-the-patients-ehrid","text":"When a patient is registered with an openCDR, a ' subjectId (normally a real-word identifier like an National identifier e.g. a Jamaican NIN number or hospital MRI) is submitted by a POST /ehr | create EHR from SubjectId call. A top-level openEHR EHR object is then created in the CDR along with a unique internal ehrId identifier for that patient. Most openCDR API calls require an 'ehrId' to identify the correct patient, so normally the first activity required if interacting with a patient record is to retrieve their ehrId , and then often to cache that identifier so it can be used for subsequent calls, until a new patient is being accessed.","title":"Retrieving the patient's ehrId"},{"location":"passport/JPASS3-querying-allergies/","text":"Querying for patient allergies This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT SELECT c / uid / value as compositionId , j / data [ at0001 ] / items [ at0002 ] / value / value as allergy_name , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / code_string as allergy_code , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / terminology_id / value as allergy_terminology , j / data [ at0001 ] / items [ at0009 ] / items [ at0011 ] / value as manifestation , j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value as onset FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c CONTAINS EVALUATION j [ openEHR - EHR - EVALUATION . adverse_reaction_risk . v1 ] ORDER BY j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/openehr/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"q\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"q\" : \"\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/openehr/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/openehr/v1/query\" payload = \"{ \\n \\\" q \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. { \"meta\" : { \"_type\" : \"RESULTSET\" , \"_created\" : \"2020-10-18T15:28:31.403Z\" , \"_executed_aql\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" }, \"q\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" , \"columns\" : [ { \"name\" : \"compositionId\" , \"path\" : \"/uid/value\" }, { \"name\" : \"allergy_name\" , \"path\" : \"/data[at0001]/items[at0002]/value/value\" }, { \"name\" : \"allergy_code\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/code_string\" }, { \"name\" : \"allergy_terminology\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/terminology_id/value\" }, { \"name\" : \"manifestation\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0011]/value\" }, { \"name\" : \"onset\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0027]/value\" } ], \"rows\" : [ [ \"b960a98f-f799-4f98-b8f1-a3e86e33035e::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Peniccilin\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Tetracycline\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Erythromicin\" , null , null , null , null ] ] }","title":"Querying for patient allergies"},{"location":"passport/JPASS3-querying-allergies/#querying-for-patient-allergies","text":"This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical","title":"Querying for patient allergies"},{"location":"passport/JPASS4-querying-medications/","text":"Querying for patient medications This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT SELECT c / uid / value as compositionId , j / data [ at0001 ] / items [ at0002 ] / value / value as allergy_name , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / code_string as allergy_code , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / terminology_id / value as allergy_terminology , j / data [ at0001 ] / items [ at0009 ] / items [ at0011 ] / value as manifestation , j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value as onset FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c CONTAINS EVALUATION j [ openEHR - EHR - EVALUATION . adverse_reaction_risk . v1 ] ORDER BY j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. { \"meta\" : { \"_type\" : \"RESULTSET\" , \"_created\" : \"2020-10-18T15:28:31.403Z\" , \"_executed_aql\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" }, \"q\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" , \"columns\" : [ { \"name\" : \"compositionId\" , \"path\" : \"/uid/value\" }, { \"name\" : \"allergy_name\" , \"path\" : \"/data[at0001]/items[at0002]/value/value\" }, { \"name\" : \"allergy_code\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/code_string\" }, { \"name\" : \"allergy_terminology\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/terminology_id/value\" }, { \"name\" : \"manifestation\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0011]/value\" }, { \"name\" : \"onset\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0027]/value\" } ], \"rows\" : [ [ \"b960a98f-f799-4f98-b8f1-a3e86e33035e::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Peniccilin\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Tetracycline\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Erythromicin\" , null , null , null , null ] ] }","title":"Querying for patient medications"},{"location":"passport/JPASS4-querying-medications/#querying-for-patient-medications","text":"This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical","title":"Querying for patient medications"},{"location":"passport/JPASS5-querying-hospitalisations/","text":"Querying for patient hospitalizations This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT SELECT c / uid / value as compositionId , j / data [ at0001 ] / items [ at0002 ] / value / value as allergy_name , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / code_string as allergy_code , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / terminology_id / value as allergy_terminology , j / data [ at0001 ] / items [ at0009 ] / items [ at0011 ] / value as manifestation , j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value as onset FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c CONTAINS EVALUATION j [ openEHR - EHR - EVALUATION . adverse_reaction_risk . v1 ] ORDER BY j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. { \"meta\" : { \"_type\" : \"RESULTSET\" , \"_created\" : \"2020-10-18T15:28:31.403Z\" , \"_executed_aql\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" }, \"q\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" , \"columns\" : [ { \"name\" : \"compositionId\" , \"path\" : \"/uid/value\" }, { \"name\" : \"allergy_name\" , \"path\" : \"/data[at0001]/items[at0002]/value/value\" }, { \"name\" : \"allergy_code\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/code_string\" }, { \"name\" : \"allergy_terminology\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/terminology_id/value\" }, { \"name\" : \"manifestation\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0011]/value\" }, { \"name\" : \"onset\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0027]/value\" } ], \"rows\" : [ [ \"b960a98f-f799-4f98-b8f1-a3e86e33035e::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Peniccilin\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Tetracycline\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Erythromicin\" , null , null , null , null ] ] }","title":"Querying for patient hospitalizations"},{"location":"passport/JPASS5-querying-hospitalisations/#querying-for-patient-hospitalizations","text":"This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical","title":"Querying for patient hospitalizations"},{"location":"passport/JPASS6-querying-immunizations/","text":"Querying for patient immunizations This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT SELECT c / uid / value as compositionId , j / data [ at0001 ] / items [ at0002 ] / value / value as allergy_name , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / code_string as allergy_code , j / data [ at0001 ] / items [ at0002 ] / value / defining_code / terminology_id / value as allergy_terminology , j / data [ at0001 ] / items [ at0009 ] / items [ at0011 ] / value as manifestation , j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value as onset FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c CONTAINS EVALUATION j [ openEHR - EHR - EVALUATION . adverse_reaction_risk . v1 ] ORDER BY j / data [ at0001 ] / items [ at0009 ] / items [ at0027 ] / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. { \"meta\" : { \"_type\" : \"RESULTSET\" , \"_created\" : \"2020-10-18T15:28:31.403Z\" , \"_executed_aql\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" }, \"q\" : \"SELECT c/uid/value as compositionId,j/data[at0001]/items[at0002]/value/value as allergy_name,\\nj/data[at0001]/items[at0002]/value/defining_code/code_string as allergy_code,\\nj/data[at0001]/items[at0002]/value/defining_code/terminology_id/value as allergy_terminology,\\n j/data[at0001]/items[at0009]/items[at0011]/value as manifestation,\\n j/data[at0001]/items[at0009]/items[at0027]/value as onset\\nFROM EHR e \\nCONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]\\nCONTAINS EVALUATION j[openEHR-EHR-EVALUATION.adverse_reaction_risk.v1] \\nORDER BY j/data[at0001]/items[at0009]/items[at0027]/value DESC\" , \"columns\" : [ { \"name\" : \"compositionId\" , \"path\" : \"/uid/value\" }, { \"name\" : \"allergy_name\" , \"path\" : \"/data[at0001]/items[at0002]/value/value\" }, { \"name\" : \"allergy_code\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/code_string\" }, { \"name\" : \"allergy_terminology\" , \"path\" : \"/data[at0001]/items[at0002]/value/defining_code/terminology_id/value\" }, { \"name\" : \"manifestation\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0011]/value\" }, { \"name\" : \"onset\" , \"path\" : \"/data[at0001]/items[at0009]/items[at0027]/value\" } ], \"rows\" : [ [ \"b960a98f-f799-4f98-b8f1-a3e86e33035e::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Peniccilin\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Tetracycline\" , null , null , null , null ], [ \"371c5ff7-5078-4c17-b426-92e7351028d0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\" , \"Erythromicin\" , null , null , null , null ] ] }","title":"Querying for patient immunizations"},{"location":"passport/JPASS6-querying-immunizations/#querying-for-patient-immunizations","text":"This section will take you through how to query for Current allergies held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the allergy name (code if available) - date of onset - manifestation (the type of Reaction -rash, nausea etc) - Exact query dataset to be finalised The exact dataset and/or queryString may change pending discussion with clinicians but the principles will remain identical","title":"Querying for patient immunizations"},{"location":"passport/JPASS7-querying-compositions/","text":"Querying for recent compositions This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT c / uid / value as compositionId , c / name / value as compositionName , c / context / start_time / value as startTime , c / composer / name as authorName , c / context / health_care_facility / name as facilityName FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c ORDER BY c / context / start_time / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. json { \"meta\": { \"_type\": \"RESULTSET\", \"_created\": \"2020-10-18T15:46:37.208Z\", \"_executed_aql\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\" }, \"q\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\", \"columns\": [ { \"name\": \"compositionId\", \"path\": \"/uid/value\" }, { \"name\": \"compositionName\", \"path\": \"/name/value\" }, { \"name\": \"startTime\", \"path\": \"/context/start_time/value\" }, { \"name\": \"authorName\", \"path\": \"/composer/name\" }, { \"name\": \"facilityName\", \"path\": \"/context/health_care_facility/name\" } ], \"rows\": [ [ \"687d40df-57d1-4d29-ab41-88396f810de0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"Passport observations\", \"2020-10-13T14:31:17.878Z\", \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\", null ], [ \"845db76d-cf06-4fca-9b62-22a7c231f31b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"NCD - first visit\", \"2020-07-22T15:17:03.696Z\", \"Dr Murphy\", null ] ] }","title":"Querying for recent compositions"},{"location":"passport/JPASS7-querying-compositions/#querying-for-recent-compositions","text":"This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility","title":"Querying for recent compositions"},{"location":"passport/JPASS8-querying-diagnoses/","text":"Querying for diagnoses This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility - the name of the diagnosis - the date of onset of the problem - the date of diagnosis Querying an openEHR CDR - Archetype Query language (AQL) A CDR can be best thought of in terms of a exposing a complex object tree with the EHR object at the top, Compositions objects handling commits, but where all of the information in the tree can be traversed and accessed. Conceptually this is a logical query/graph language like SPARQL, the key difference being that the exact paths to the objects you might need to access are defined in the archetypes and templates you use to define and validate the data. AQL can be written by hand but is normally done using a tool like the Better Studio Understanding AQL is not generally important for third-party developers. Normally the correct AQL will be supplied by the CDR owner, indeed in production it is much more likely that server-side stored queries would be used. POST /query | Run an ad-hoc AQL query This example will retrieve the data requirement above. To run the query - a querystring needs to be carried in the body of the POST call as raw data with the Header Content-Type set to `application/json' This is the queryString: that we need to send. SELECT c / uid / value as compositionId , c / name / value as compositionName , c / context / start_time / value as startTime , c / composer / name as authorName , c / context / health_care_facility / name as facilityName FROM EHR e [ ehr_id / value = '' ] CONTAINS COMPOSITION c ORDER BY c / context / start_time / value DESC Note the ehrId substitution You will need to make sure that the ehrId variable in the queryString is substituted with the correct ehrId for the patient concerned. Don't worry about this seemingly odd format -it is essentially a mix of SQL and a path-based syntax, like SPARQL or XQuery. Running the query is easy- just call the POST /query call, sending the AQL string in the body of the request but note that you should strip the string of any linefeed and carriage returns etc. The Postman 'Ad-hoc query' request has a utility function under 'Pre-req' that sanitises the string and sets it into an environment variable before inserting it into the request body. Postman cURL curl --location --request POST 'https://rest.ehrscape.com/rest/v1/query' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ== \\ --data-raw '{ \"aql\": \"\" }' NodeJs - Axios var axios = require ( 'axios' ); var data = JSON . stringify ({ \"aql\" : \"SELECT ... FROM ... CONTAINS ... WHERE\" }); var config = { method : 'post' , url : 'https://rest.ehrscape.com/rest/v1/query' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' }, data : data }; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }) . catch ( function ( error ) { console . log ( error ); }); Python/requests import requests url = \"https://https://rest.ehrscape.com/rest/v1/query\" payload = \"{ \\n \\\" aql \\\" : \\\"\\\"\\n }\" headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'Basic YTgxZjQ3YzYtYTc1Ny00ZTM0LWI2NDQtM2NjYzYyYjRhMDFjOiQyYSQxMCQ2MTlraQ==' } response = requests . request ( \"POST\" , url , headers = headers , data = payload ) print ( response . text . encode ( 'utf8' )) Response The AQL response comes as back as an openEHR resultSet , which is a tabular shape, the exact format being determined by the AQL itself. In this example we have asked for scalar values only, but it is possible for AQL to return objects. The columns object shows the openEHR paths and aliases that are are returned in each row. json { \"meta\": { \"_type\": \"RESULTSET\", \"_created\": \"2020-10-18T15:46:37.208Z\", \"_executed_aql\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\" }, \"q\": \"SELECT c/uid/value as compositionId, c/name/value as compositionName,\\nc/context/start_time/value as startTime, c/composer/name as authorName, c/context/health_care_facility/name as facilityName\\nFROM EHR e \\nCONTAINS COMPOSITION c\\n \\nORDER BY c/context/start_time/value DESC\", \"columns\": [ { \"name\": \"compositionId\", \"path\": \"/uid/value\" }, { \"name\": \"compositionName\", \"path\": \"/name/value\" }, { \"name\": \"startTime\", \"path\": \"/context/start_time/value\" }, { \"name\": \"authorName\", \"path\": \"/composer/name\" }, { \"name\": \"facilityName\", \"path\": \"/context/health_care_facility/name\" } ], \"rows\": [ [ \"687d40df-57d1-4d29-ab41-88396f810de0::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"Passport observations\", \"2020-10-13T14:31:17.878Z\", \"moh-jamaica_4cce5a07-be4d-4318-a94f-3b8401853a20\", null ], [ \"845db76d-cf06-4fca-9b62-22a7c231f31b::4cce5a07-be4d-4318-a94f-3b8401853a20::1\", \"NCD - first visit\", \"2020-07-22T15:17:03.696Z\", \"Dr Murphy\", null ] ] }","title":"Querying for diagnoses"},{"location":"passport/JPASS8-querying-diagnoses/#querying-for-diagnoses","text":"This section will take you through how to query for recent Compositions held on the CDR, using AQL (Archetype Query Language) The initial proposed dataset is - the name of Composition - the composition identifier - the start date of the Composition - the name of the clinical author (composer) - the name of the healthcare facility - the name of the diagnosis - the date of onset of the problem - the date of diagnosis","title":"Querying for diagnoses"},{"location":"passport/JPASS9-committing-observation-data/","text":"Committing Observation data All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference model schema. If the data is valid, it will be stored in the CDR and is allocated a unique ID, which is returned by the POST /composition call This section will submit an example Composition to the CDR by running a POST / composition call. A number of data serialisation options, can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON or XML formats. Note Note that this example uses the Better Better Ehrscape API which has a slightly different base URL and parameters than the openEHR REST API ,though the data is stored identically and can be accessed from both end points. Ehrscape POST /composition example Parameters ehrId : This is is the internal CDR identifier for a specific patient. When a patient is registered with the CDR,an EHR object is created with a unique ehr_id identifier, and is associated with an external subjectId and subjectNamespace e.g an NHS Number, CHI number, or a local hospital number. We will find out how to work out the correct ehrId for a patient in the next section. Generally when you first open a patient record session, you will retrieve their ehrId via their subjectID and subjectNamespace . We will explain how to do that in the next section. For testing purposes, you should use a known ehrId . If you have a Postman environment file, an example will be in there, otherwise you can find out how to identify valid ehrIds here templateId : This is the identifier of the openEHR template, against which you need to validate the composition. Use DHI - Urology_PROMs-v0 for this example. format : This defines the format of JSON or XML that you are sending. Use FLAT for this example. A. Commit an openEHR Composition ( FLAT JSON ) cURL curl --location --request POST '/composition?ehrId=&templateId=&format=STRUCTURED' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: ' \\ --data-raw '{ \"{ \"passport_observations/context/start_time\": \"2020-10-18T16:16:21.449Z\", \"passport_observations/context/setting|code\": \"238\", \"passport_observations/context/setting|value\": \"other care\", \"passport_observations/context/setting|terminology\": \"openehr\", \"passport_observations/blood_pressure/systolic|magnitude\": 169.0, \"passport_observations/blood_pressure/systolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/diastolic|magnitude\": 692.0, \"passport_observations/blood_pressure/diastolic|unit\": \"mm[Hg]\", \"passport_observations/blood_pressure/time\": \"2020-10-18T16:16:21.452Z\", \"passport_observations/blood_pressure/language|code\": \"en\", \"passport_observations/blood_pressure/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_pressure/encoding|code\": \"UTF-8\", \"passport_observations/blood_pressure/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/height_length/height_length|magnitude\": 609.33, \"passport_observations/height_length/height_length|unit\": \"cm\", \"passport_observations/height_length/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/height_length/language|code\": \"en\", \"passport_observations/height_length/language|terminology\": \"ISO_639-1\", \"passport_observations/height_length/encoding|code\": \"UTF-8\", \"passport_observations/height_length/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_weight/weight|magnitude\": 380.49, \"passport_observations/body_weight/weight|unit\": \"kg\", \"passport_observations/body_weight/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/body_weight/language|code\": \"en\", \"passport_observations/body_weight/language|terminology\": \"ISO_639-1\", \"passport_observations/body_weight/encoding|code\": \"UTF-8\", \"passport_observations/body_weight/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/blood_glucose/test_name|code\": \"14743-9\", \"passport_observations/blood_glucose/test_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/test_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|code\": \"14743-9\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|value\": \"Glucose [Moles/volume] in Capillary blood by Glucometer\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_name|terminology\": \"LOINC\", \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|magnitude\": 52.61, \"passport_observations/blood_glucose/laboratory_analyte_result/analyte_result|unit\": \"mmol/L\", \"passport_observations/blood_glucose/time\": \"2020-10-18T16:16:21.453Z\", \"passport_observations/blood_glucose/language|code\": \"en\", \"passport_observations/blood_glucose/language|terminology\": \"ISO_639-1\", \"passport_observations/blood_glucose/encoding|code\": \"UTF-8\", \"passport_observations/blood_glucose/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/pulse_oximetry/spo|numerator\": 0.0, \"passport_observations/pulse_oximetry/spo|denominator\": 100.0, \"passport_observations/pulse_oximetry/spo|type\": 2, \"passport_observations/pulse_oximetry/spo\": 0.0, \"passport_observations/pulse_oximetry/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/pulse_oximetry/language|code\": \"en\", \"passport_observations/pulse_oximetry/language|terminology\": \"ISO_639-1\", \"passport_observations/pulse_oximetry/encoding|code\": \"UTF-8\", \"passport_observations/pulse_oximetry/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/body_temperature/temperature|magnitude\": 72.7, \"passport_observations/body_temperature/temperature|unit\": \"[degF]\", \"passport_observations/body_temperature/time\": \"2020-10-18T16:16:21.455Z\", \"passport_observations/body_temperature/language|code\": \"en\", \"passport_observations/body_temperature/language|terminology\": \"ISO_639-1\", \"passport_observations/body_temperature/encoding|code\": \"UTF-8\", \"passport_observations/body_temperature/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/clinical_synopsis/notes\": \"Notes 9\", \"passport_observations/clinical_synopsis/language|code\": \"en\", \"passport_observations/clinical_synopsis/language|terminology\": \"ISO_639-1\", \"passport_observations/clinical_synopsis/encoding|code\": \"UTF-8\", \"passport_observations/clinical_synopsis/encoding|terminology\": \"IANA_character-sets\", \"passport_observations/category|code\": \"433\", \"passport_observations/category|value\": \"event\", \"passport_observations/category|terminology\": \"openehr\", \"passport_observations/language|code\": \"en\", \"passport_observations/language|terminology\": \"ISO_639-1\", \"passport_observations/territory|code\": \"JM\", \"passport_observations/territory|terminology\": \"ISO_3166-1\" }' NodeJS + Axios ```js var axios = require ( 'axios' ); var data = JSON . stringify ( { \"prostate_cancer_proms_report\" : // trimmed for brevity }\" ); var config = { method : 'post' , url : '/composition?ehrId=&templateId=&format=STRUCTURED' , headers : { 'Content-Type' : 'application/json' , 'Authorization' : '' } , data : data } ; axios ( config ) . then ( function ( response ) { console . log ( JSON . stringify ( response . data )); } ) . catch ( function ( error ) { console . log ( error ); } ); ``` Response for POST /composition { \"meta\" : { \"href\" : \"https://cdr.code4health.org/rest/v1/composition/59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" }, \"action\" : \"CREATE\" , \"compositionUid\" : \"59e8f5a2-6fb6-47d5-9acd-ae6309d0f1dd::a81f47c6-a757-4e34-b644-3ccc62b4a01c::1\" } The Composition Id The compositionUid is the unique identifier allocated to (and held within) every composition by the CDR. You will see that it ends in ...::1 . The 1 is the version of this composition instance. If you need to update the instance (perhaps because of an error), you need to do so via a PUT / composition call and if successful the composition version number will clock up to ::2 . In essence every commit is versioned and retained for medico-legal reasons. Similarly when a composition is deleted, this is a logical delete and the composition can always be retrieved, though is not normally accessible via querying. We will go through the process of updating a composition later. For now let's just retrieve the composition we just committed, via the GET /composition call.","title":"Committing Observation data"},{"location":"passport/JPASS9-committing-observation-data/#committing-observation-data","text":"All data committed to an openEHR CDR is done so via a POST /composition call - as a JSON or XML 'blob'. As it is committed, the data will be validated against both the appropriate openEHR template and the underlying Reference model schema. If the data is valid, it will be stored in the CDR and is allocated a unique ID, which is returned by the POST /composition call This section will submit an example Composition to the CDR by running a POST / composition call. A number of data serialisation options, can be used. In this case we will use the Better STRUCTURED JSON format, as it is somewhat easier to use than the current openEHR CANONICAL JSON or XML formats. Note Note that this example uses the Better Better Ehrscape API which has a slightly different base URL and parameters than the openEHR REST API ,though the data is stored identically and can be accessed from both end points.","title":"Committing Observation data"},{"location":"postman/PM1-postman-getting-ready/","text":"First you need to install a copy of the API runner application Postman (Chrome/MacOS/Windows) Get Postman Application This lets you send and receive data from the openEHR REST API or Better Ehrscape API without the need for a specific programming language. Postman also allows you to import a preset collection of API calls which we can use to supply a copy of the Ehrscape API and associated 'environment' file, which contains settings for a specific C4H Platform domain domain. A. Run Postman Click the 'Run Postman Button' to import the Postman 'Apperta C4H openEHR REST APIs' collection and the associated 'dhi-scotland' environment. or B. Download Postman files from Git Click on these links to download the files to your system: TBD or C. Download your collection files from email If you have received an email containing the collection and environment files to use with Postman. The first step is to download these files ready to then be imported into Postman. Find Apperta C4H openEHR REST API.postman_collection in your email and download it to a folder of your choice (normally the Download folder). Find <your_environment_name>.postman_environment in your email and download it to a folder of your choice (normally the Download folder). Please note that for demonstration purposes we are using the C4H Ripple OSI environment in this document. Import Downloaded files into Postman If you have downloaded files from Github of from your email, these now need to be installed in Postman. Open Postman and select Import Locate your two save files and import them. You can either use the Choose Files option to import one at a time or drag and drop the files into the window In the top right hand corner, change the environment to your environment (in the screenshot below that\u2019s the C4H Ripple OSI environment) On the left hand side you can now see the collection files ...","title":"Getting ready with Postman"},{"location":"postman/PM1-postman-getting-ready/#a-run-postman","text":"Click the 'Run Postman Button' to import the Postman 'Apperta C4H openEHR REST APIs' collection and the associated 'dhi-scotland' environment.","title":"A. Run Postman"},{"location":"postman/PM1-postman-getting-ready/#or-b-download-postman-files-from-git","text":"Click on these links to download the files to your system: TBD","title":"or B. Download Postman files from Git"},{"location":"postman/PM1-postman-getting-ready/#or-c-download-your-collection-files-from-email","text":"If you have received an email containing the collection and environment files to use with Postman. The first step is to download these files ready to then be imported into Postman. Find Apperta C4H openEHR REST API.postman_collection in your email and download it to a folder of your choice (normally the Download folder). Find <your_environment_name>.postman_environment in your email and download it to a folder of your choice (normally the Download folder). Please note that for demonstration purposes we are using the C4H Ripple OSI environment in this document.","title":"or C. Download your collection files from email"},{"location":"postman/PM1-postman-getting-ready/#import-downloaded-files-into-postman","text":"If you have downloaded files from Github of from your email, these now need to be installed in Postman. Open Postman and select Import Locate your two save files and import them. You can either use the Choose Files option to import one at a time or drag and drop the files into the window In the top right hand corner, change the environment to your environment (in the screenshot below that\u2019s the C4H Ripple OSI environment) On the left hand side you can now see the collection files ...","title":"Import Downloaded files into Postman"},{"location":"postman/PM2-navigate-postman/","text":"Something else Click on the openEHR Ehrscape Clinical Data Repository to reveal the folders, and then click on individual folders to expand and reveal the contents Selecting one of the API calls displays more detail on the right hand side Clicking on the \"x\" icon in the top right hand corner reveals a number of pre-set variables for your selected environment (again the C4H Ripple environment is used just as an example). These pre-sets are used in some of the API calls as defaults.","title":"Navigate Postman"},{"location":"postman/PM3-using-postman/","text":"Create Session (Ripple Ethercis only) You can skip this step if you are not using the Ripple Ethercis CDR. The first step is to create an openEHR session and retrieve the sessionId token. This allows subsequent API calls to be made without needing to login on each occasion. Navigate to the session folder and highlight Create Session on the left, then click on the Send button. The required credentials are automatically filled in from the Pre-sets file (see Navigating Postman section above) Click the Scroll to responses button in the bottom right hand corner to display the response details. The screenshot below shows the session Id which has been returned in the call. Get EHR Identifier The next step is to get the patient\u2019s internal EHR identifier by sending their external identifier (in this case an NHS Number). The ehrId is a unique string which, for security reasons, cannot be associated with the patient, if for instance their openEHR records were leaked. Select Get ehrStatus from subjectId in the ehr folder and then click on the Send button. Again, the patient\u2019s NHS number is taken from the Pre-sets file and is therefore filled in automatically. Click on the Scroll to responses button in the bottom right hand corner to display the response details. The JSON snippet below shows the ehrId for our dummy patient. To store the returned ehrId as a pre-set for the selected environment, highlight the string in the response details, right mouse click, set the environment ( C4H Ripple OSI in this example ) and then select ehrId from the list of attributes. Retrieve Composition ID Now that we have the patient\u2019s EHR identifier, we can use it to locate and retrieve some clinical details. We use an Archetype Query Language (AQL) call to retrieve a list of the identifiers and dates of existing Nursing Vital Signs Observations Composition records. Compositions are document-level records which act as the container for all openEHR patient data. The name/value of the Composition is the root name of the templates composition archetype (case-sensitive). In a real-world example we would query on other factors to ensure we had the \u2018correct\u2019 list. The query we need to run in order to get the composition Id for the most recent vital signs composition for the selected patient is as follows: At this stage you don\u2019t need to worry about the exact syntax and how to create an AQL query. These topics are covered elsewhere, and the Specifications provide the required details. Open the query folder and select Ad-hoc query This is the query string in a format which can be copied and pasted: select a / uid / value as compositionId , a / context / start_time / value as start_time from EHR e [ ehr_id / value = '' ] contains COMPOSITION a [ openEHR - EHR - COMPOSITION . encounter . v1 ] where a / name / value = 'Nursing Vital Signs Observations' order by a / context / start_time / value desc offset 0 limit 1 In the Ad-hoc Query window click on Param and paste the query string above into the Value field, then click on the Send button. Click the Scroll to response button in the bottom right hand corner to display the response details. The compositionId element in the response is the unqique identifier for the composition and the start_time is the time that the document was authored. We will use the results of this query to retrieve the full composition, so the final action is to store the composition Id as a pre-set. Highlight the string in the response details, right mouse click, set the environment ( C4H Ripple OSI in this example) and then select compositionId from the list of attributes Retrieve Composition The next step is to retrieve the composition itself, based on the compositionId we stored in the previous step. Navigate to the composition folder and highlight Read Composition JSON FLAT , then click the Send button The result is shown as a FLAT JSON file below Other formats are JSON RAW, XML RAW or JSON STRUCTURED \u2013 the snippets below show part of the Pulse data Persist Composition The next step is to persist a new composition. The data in the composition is validated against a template, and the first action is to set the correct template Id for composition to be persisted. Navigate to the Template folder and highlight List available templates , then click the Send button. Highlight the Vital Signs Encounter template in the list of available templates, right mouse click, set the environment ( C4H Ripple OSI in this example) and then select templateId from the list of attributes Once the template Id is set, we can commit a composition. The following string is an example of a vital signs composition: \"ctx/language\" : \"en\" , \"ctx/territory\" : \"GB\" , \"ctx/composer_name\" : \"Hazel Smith\" , \"ctx/time\" : \"2015-12-10T02:19:00.000Z\" , \"ctx/health_care_facility|id\" : \"999999-345\" , \"ctx/health_care_facility|name\" : \"Northumbria Community NHS\" , \"ctx/id_namespace\" : \"NHS-UK\" , \"ctx/id_scheme\" : \"2.16.840.1.113883.2.1.4.3\" , \"nursing_vital_signs_observations/vital_signs:0/respirations:0/any_event:0/rate|magnitude\" : 22 , \"nursing_vital_signs_observations/vital_signs:0/respirations:0/any_event:0/rate|unit\" : \"/min\" , \"nursing_vital_signs_observations/vital_signs:0/pulse:0/any_event:0/heart_rate|magnitude\" : 101 , \"nursing_vital_signs_observations/vital_signs:0/pulse:0/any_event:0/heart_rate|unit\" : \"/min\" , \"nursing_vital_signs_observations/vital_signs:0/body_temperature:0/any_event:0/temperature|magnitude\" : 36.6 , \"nursing_vital_signs_observations/vital_signs:0/body_temperature:0/any_event:0/temperature|unit\" : \"\u00b0C\" , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/systolic|magnitude\" : 100 , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/systolic|unit\" : \"mm[Hg]\" , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/diastolic|magnitude\" : 60 , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/diastolic|unit\" : \"mm[Hg]\" , \"nursing_vital_signs_observations/vital_signs:0/indirect_oximetry:0/any_event:0/spo2|numerator\" : 94 , \"nursing_vital_signs_observations/vital_signs:0/indirect_oximetry:0/any_event:0/spo2|denominator\" : 100 , \"nursing_vital_signs_observations/vital_signs:0/national_early_warning_score_rcp_uk:0/total_score\" : 3 _ * As mentioned before, the exact syntax and how to create a composition will be covered elsewhere. At this stage you should just use the syntax string provided above. Navigate to the Composition folder and highlight Commit Composition JSON FLAT . Paste the text above into the Body text box on the right hand side and click on the Send button. The result shows the composition Id for the newly committed composition. Run AQL Query The next step is to run a query on recent vital signs compositions and return a set of key data. Navigate to the query folder and select Ad-hoc Query . This is the query string we are going to use to retrieve the last 5 vital signs compositions and return the relevant readings. Once again, just to clarify: the exact syntax and how to create an AQL query will be covered elsewhere. At this stage you can just copy and paste the query syntax string shown below: select a / uid / value as compositionId , a / context / start_time / value as start_time , b_a / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0004 ] / value / magnitude as Rate_magnitude , b_b / data [ at0002 ] / events [ at0003 ] / data [ at0001 ] / items [ at0004 ] / value / magnitude as Heart_Rate_magnitude , b_c / data [ at0002 ] / events [ at0003 ] / data [ at0001 ] / items [ at0004 ] / value / magnitude as Temperature_magnitude , b_f / data [ at0001 ] / events [ at0006 ] / data [ at0003 ] / items [ at0004 ] / value / magnitude as Systolic_magnitude , b_f / data [ at0001 ] / events [ at0006 ] / data [ at0003 ] / items [ at0005 ] / value / magnitude as Diastolic_magnitude , b_g / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0006 ] / value / numerator as spO2_numerator , b_h / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0028 ] / value / magnitude as Total_Score_magnitude from EHR e [ ehr_id / value = '' ] contains COMPOSITION a [ openEHR - EHR - COMPOSITION . encounter . v1 ] contains ( OBSERVATION b_a [ openEHR - EHR - OBSERVATION . respiration . v1 ] or OBSERVATION b_b [ openEHR - EHR - OBSERVATION . pulse . v1 ] or OBSERVATION b_c [ openEHR - EHR - OBSERVATION . body_temperature . v1 ] or OBSERVATION b_f [ openEHR - EHR - OBSERVATION . blood_pressure . v1 ] or OBSERVATION b_g [ openEHR - EHR - OBSERVATION . indirect_oximetry . v1 ] or OBSERVATION b_h [ openEHR - EHR - OBSERVATION . news_rcp_uk . v1 ]) where a / name / value = 'Nursing Vital Signs Observations' order by a / context / start_time / value desc In the Ad-hoc query window click on Params and enter the query string into the Value field on the right hand side, then click the Send button. The result set contains the last 5 vital signs compositions and the data points within the compositions. Close Session(Ripple EtherCis only) The final step is to close the openEHR session. To do this, navigate to the session folder and select Delete Session . Click on the Send button. The result will show a null sessionId, indicating that there is no open session.","title":"Using Postman with Ehrscape"},{"location":"postman/PM3-using-postman/#create-session-ripple-ethercis-only","text":"You can skip this step if you are not using the Ripple Ethercis CDR. The first step is to create an openEHR session and retrieve the sessionId token. This allows subsequent API calls to be made without needing to login on each occasion. Navigate to the session folder and highlight Create Session on the left, then click on the Send button. The required credentials are automatically filled in from the Pre-sets file (see Navigating Postman section above) Click the Scroll to responses button in the bottom right hand corner to display the response details. The screenshot below shows the session Id which has been returned in the call.","title":"Create Session (Ripple Ethercis only)"},{"location":"postman/PM3-using-postman/#get-ehr-identifier","text":"The next step is to get the patient\u2019s internal EHR identifier by sending their external identifier (in this case an NHS Number). The ehrId is a unique string which, for security reasons, cannot be associated with the patient, if for instance their openEHR records were leaked. Select Get ehrStatus from subjectId in the ehr folder and then click on the Send button. Again, the patient\u2019s NHS number is taken from the Pre-sets file and is therefore filled in automatically. Click on the Scroll to responses button in the bottom right hand corner to display the response details. The JSON snippet below shows the ehrId for our dummy patient. To store the returned ehrId as a pre-set for the selected environment, highlight the string in the response details, right mouse click, set the environment ( C4H Ripple OSI in this example ) and then select ehrId from the list of attributes.","title":"Get EHR Identifier"},{"location":"postman/PM3-using-postman/#retrieve-composition-id","text":"Now that we have the patient\u2019s EHR identifier, we can use it to locate and retrieve some clinical details. We use an Archetype Query Language (AQL) call to retrieve a list of the identifiers and dates of existing Nursing Vital Signs Observations Composition records. Compositions are document-level records which act as the container for all openEHR patient data. The name/value of the Composition is the root name of the templates composition archetype (case-sensitive). In a real-world example we would query on other factors to ensure we had the \u2018correct\u2019 list. The query we need to run in order to get the composition Id for the most recent vital signs composition for the selected patient is as follows: At this stage you don\u2019t need to worry about the exact syntax and how to create an AQL query. These topics are covered elsewhere, and the Specifications provide the required details. Open the query folder and select Ad-hoc query This is the query string in a format which can be copied and pasted: select a / uid / value as compositionId , a / context / start_time / value as start_time from EHR e [ ehr_id / value = '' ] contains COMPOSITION a [ openEHR - EHR - COMPOSITION . encounter . v1 ] where a / name / value = 'Nursing Vital Signs Observations' order by a / context / start_time / value desc offset 0 limit 1 In the Ad-hoc Query window click on Param and paste the query string above into the Value field, then click on the Send button. Click the Scroll to response button in the bottom right hand corner to display the response details. The compositionId element in the response is the unqique identifier for the composition and the start_time is the time that the document was authored. We will use the results of this query to retrieve the full composition, so the final action is to store the composition Id as a pre-set. Highlight the string in the response details, right mouse click, set the environment ( C4H Ripple OSI in this example) and then select compositionId from the list of attributes","title":"Retrieve Composition ID"},{"location":"postman/PM3-using-postman/#retrieve-composition","text":"The next step is to retrieve the composition itself, based on the compositionId we stored in the previous step. Navigate to the composition folder and highlight Read Composition JSON FLAT , then click the Send button The result is shown as a FLAT JSON file below Other formats are JSON RAW, XML RAW or JSON STRUCTURED \u2013 the snippets below show part of the Pulse data","title":"Retrieve Composition"},{"location":"postman/PM3-using-postman/#persist-composition","text":"The next step is to persist a new composition. The data in the composition is validated against a template, and the first action is to set the correct template Id for composition to be persisted. Navigate to the Template folder and highlight List available templates , then click the Send button. Highlight the Vital Signs Encounter template in the list of available templates, right mouse click, set the environment ( C4H Ripple OSI in this example) and then select templateId from the list of attributes Once the template Id is set, we can commit a composition. The following string is an example of a vital signs composition: \"ctx/language\" : \"en\" , \"ctx/territory\" : \"GB\" , \"ctx/composer_name\" : \"Hazel Smith\" , \"ctx/time\" : \"2015-12-10T02:19:00.000Z\" , \"ctx/health_care_facility|id\" : \"999999-345\" , \"ctx/health_care_facility|name\" : \"Northumbria Community NHS\" , \"ctx/id_namespace\" : \"NHS-UK\" , \"ctx/id_scheme\" : \"2.16.840.1.113883.2.1.4.3\" , \"nursing_vital_signs_observations/vital_signs:0/respirations:0/any_event:0/rate|magnitude\" : 22 , \"nursing_vital_signs_observations/vital_signs:0/respirations:0/any_event:0/rate|unit\" : \"/min\" , \"nursing_vital_signs_observations/vital_signs:0/pulse:0/any_event:0/heart_rate|magnitude\" : 101 , \"nursing_vital_signs_observations/vital_signs:0/pulse:0/any_event:0/heart_rate|unit\" : \"/min\" , \"nursing_vital_signs_observations/vital_signs:0/body_temperature:0/any_event:0/temperature|magnitude\" : 36.6 , \"nursing_vital_signs_observations/vital_signs:0/body_temperature:0/any_event:0/temperature|unit\" : \"\u00b0C\" , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/systolic|magnitude\" : 100 , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/systolic|unit\" : \"mm[Hg]\" , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/diastolic|magnitude\" : 60 , \"nursing_vital_signs_observations/vital_signs:0/blood_pressure:0/any_event:0/diastolic|unit\" : \"mm[Hg]\" , \"nursing_vital_signs_observations/vital_signs:0/indirect_oximetry:0/any_event:0/spo2|numerator\" : 94 , \"nursing_vital_signs_observations/vital_signs:0/indirect_oximetry:0/any_event:0/spo2|denominator\" : 100 , \"nursing_vital_signs_observations/vital_signs:0/national_early_warning_score_rcp_uk:0/total_score\" : 3 _ * As mentioned before, the exact syntax and how to create a composition will be covered elsewhere. At this stage you should just use the syntax string provided above. Navigate to the Composition folder and highlight Commit Composition JSON FLAT . Paste the text above into the Body text box on the right hand side and click on the Send button. The result shows the composition Id for the newly committed composition.","title":"Persist Composition"},{"location":"postman/PM3-using-postman/#run-aql-query","text":"The next step is to run a query on recent vital signs compositions and return a set of key data. Navigate to the query folder and select Ad-hoc Query . This is the query string we are going to use to retrieve the last 5 vital signs compositions and return the relevant readings. Once again, just to clarify: the exact syntax and how to create an AQL query will be covered elsewhere. At this stage you can just copy and paste the query syntax string shown below: select a / uid / value as compositionId , a / context / start_time / value as start_time , b_a / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0004 ] / value / magnitude as Rate_magnitude , b_b / data [ at0002 ] / events [ at0003 ] / data [ at0001 ] / items [ at0004 ] / value / magnitude as Heart_Rate_magnitude , b_c / data [ at0002 ] / events [ at0003 ] / data [ at0001 ] / items [ at0004 ] / value / magnitude as Temperature_magnitude , b_f / data [ at0001 ] / events [ at0006 ] / data [ at0003 ] / items [ at0004 ] / value / magnitude as Systolic_magnitude , b_f / data [ at0001 ] / events [ at0006 ] / data [ at0003 ] / items [ at0005 ] / value / magnitude as Diastolic_magnitude , b_g / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0006 ] / value / numerator as spO2_numerator , b_h / data [ at0001 ] / events [ at0002 ] / data [ at0003 ] / items [ at0028 ] / value / magnitude as Total_Score_magnitude from EHR e [ ehr_id / value = '' ] contains COMPOSITION a [ openEHR - EHR - COMPOSITION . encounter . v1 ] contains ( OBSERVATION b_a [ openEHR - EHR - OBSERVATION . respiration . v1 ] or OBSERVATION b_b [ openEHR - EHR - OBSERVATION . pulse . v1 ] or OBSERVATION b_c [ openEHR - EHR - OBSERVATION . body_temperature . v1 ] or OBSERVATION b_f [ openEHR - EHR - OBSERVATION . blood_pressure . v1 ] or OBSERVATION b_g [ openEHR - EHR - OBSERVATION . indirect_oximetry . v1 ] or OBSERVATION b_h [ openEHR - EHR - OBSERVATION . news_rcp_uk . v1 ]) where a / name / value = 'Nursing Vital Signs Observations' order by a / context / start_time / value desc In the Ad-hoc query window click on Params and enter the query string into the Value field on the right hand side, then click the Send button. The result set contains the last 5 vital signs compositions and the data points within the compositions.","title":"Run AQL Query"},{"location":"postman/PM3-using-postman/#close-sessionripple-ethercis-only","text":"The final step is to close the openEHR session. To do this, navigate to the session folder and select Delete Session . Click on the Send button. The result will show a null sessionId, indicating that there is no open session.","title":"Close Session(Ripple EtherCis only)"}]}